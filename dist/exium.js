var ContextTypes1;
(function (ContextTypes1) {
  ContextTypes1["Unexpected"] = "Unexpected";
  ContextTypes1["Space"] = "Space";
  ContextTypes1["Identifier"] = "Identifier";
  ContextTypes1["AsStatement"] = "AsStatement";
  ContextTypes1["Asterix"] = "Asterix";
  ContextTypes1["IdentifierAsStatement"] = "IdentifierAsStatement";
  ContextTypes1["IdentifierList"] = "IdentifierList";
  ContextTypes1["IdentifierSemiColonList"] = "IdentifierSemiColonList";
  ContextTypes1["At"] = "At";
  ContextTypes1["SemiColon"] = "SemiColon";
  ContextTypes1["Coma"] = "Coma";
  ContextTypes1["DoublePoint"] = "DoublePoint";
  ContextTypes1["Point"] = "Point";
  ContextTypes1["MultipleSpaces"] = "MultipleSpaces";
  ContextTypes1["LineBreak"] = "LineBreak";
  ContextTypes1["StringSingleQuote"] = "StringSingleQuote";
  ContextTypes1["StringDoubleQuote"] = "StringDoubleQuote";
  ContextTypes1["StringTemplateQuote"] = "StringTemplateQuote";
  ContextTypes1["StringTemplateQuoteEval"] = "StringTemplateQuoteEval";
  ContextTypes1["Comment"] = "Comment";
  ContextTypes1["CommentBlock"] = "CommentBlock";
  ContextTypes1["Braces"] = "Braces";
  ContextTypes1["CurlyBrackets"] = "CurlyBrackets";
  ContextTypes1["Array"] = "Array";
  ContextTypes1["Parenthese"] = "Parenthese";
  ContextTypes1["Argument"] = "Argument";
  ContextTypes1["ComponentTypeStatement"] = "ComponentTypeStatement";
  ContextTypes1["ComponentDeclaration"] = "ComponentDeclaration";
  ContextTypes1["HTMLComment"] = "HTMLComment";
  ContextTypes1["ImportAmbient"] = "ImportAmbient";
  ContextTypes1["ImportStatement"] = "ImportStatement";
  ContextTypes1["ExportStatement"] = "ExportStatement";
  ContextTypes1["ImportComponentStatement"] = "ImportComponentStatement";
  ContextTypes1["ImportStatementFrom"] = "ImportStatementFrom";
  ContextTypes1["ImportAllAlias"] = "ImportAllAlias";
  ContextTypes1["InjectAmbient"] = "InjectAmbient";
  ContextTypes1["TextNode"] = "TextNode";
  ContextTypes1["Node"] = "Node";
  ContextTypes1["NodeOpening"] = "NodeOpening";
  ContextTypes1["NodeOpeningEnd"] = "NodeOpeningEnd";
  ContextTypes1["NodeClosing"] = "NodeClosing";
  ContextTypes1["NodeClosingEnd"] = "NodeClosingEnd";
  ContextTypes1["Flag"] = "Flag";
  ContextTypes1["FlagStruct"] = "FlagStruct";
  ContextTypes1["FlagSpread"] = "FlagSpread";
  ContextTypes1["Attribute"] = "Attribute";
  ContextTypes1["AttributeModifier"] = "AttributeModifier";
  ContextTypes1["AttributeModifierType"] = "AttributeModifierType";
  ContextTypes1["AttributeProperty"] = "AttributeProperty";
  ContextTypes1["AttributeBoolean"] = "AttributeBoolean";
  ContextTypes1["AttributeValueQuoteSingle"] = "AttributeValueQuoteSingle";
  ContextTypes1["AttributeValueQuoteDouble"] = "AttributeValueQuoteDouble";
  ContextTypes1["AttributeValueQuoteTemplate"] = "AttributeValueQuoteTemplate";
  ContextTypes1["AttributeValueCurlyBrackets"] = "AttributeValueCurlyBrackets";
  ContextTypes1["AttributeValueUnquoted"] = "AttributeValueUnquoted";
  ContextTypes1["AttributeValueBraces"] = "AttributeValueBraces";
  ContextTypes1["AttributeValueArray"] = "AttributeValueArray";
  ContextTypes1["AttributeValueContent"] = "AttributeValueContent";
  ContextTypes1["AttributeValueStart"] = "AttributeValueStart";
  ContextTypes1["AttributeValueEnd"] = "AttributeValueEnd";
  ContextTypes1["Protocol"] = "Protocol";
  ContextTypes1["StyleSheet"] = "StyleSheet";
  ContextTypes1["StyleSheetEnd"] = "StyleSheetEnd";
  ContextTypes1["StyleSheetRule"] = "StyleSheetRule";
  ContextTypes1["StyleSheetAtRule"] = "StyleSheetAtRule";
  ContextTypes1["StyleSheetAtRuleCharset"] = "StyleSheetAtRuleCharset";
  ContextTypes1["StyleSheetTypeAssignment"] = "StyleSheetTypeAssignment";
  ContextTypes1["StyleSheetAtRuleConst"] = "StyleSheetAtRuleConst";
  ContextTypes1["StyleSheetAtRuleConstType"] = "StyleSheetAtRuleConstType";
  ContextTypes1["StyleSheetAtRuleConstEqual"] = "StyleSheetAtRuleConstEqual";
  ContextTypes1["StyleSheetAtRuleConstValue"] = "StyleSheetAtRuleConstValue";
  ContextTypes1["StyleSheetAtRuleExport"] = "StyleSheetAtRuleExport";
  ContextTypes1["StyleSheetType"] = "StyleSheetType";
  ContextTypes1["StyleSheetCurlyBrackets"] = "StyleSheetCurlyBrackets";
  ContextTypes1["StyleSheetRuleSpread"] = "StyleSheetRuleSpread";
  ContextTypes1["StyleSheetParentRef"] = "StyleSheetParentRef";
  ContextTypes1["StyleSheetPropertyList"] = "StyleSheetPropertyList";
  ContextTypes1["StyleSheetProperty"] = "StyleSheetProperty";
  ContextTypes1["StyleSheetPropertyValue"] = "StyleSheetPropertyValue";
  ContextTypes1["StyleSheetPseudoProperty"] = "StyleSheetPseudoProperty";
  ContextTypes1["StyleSheetPseudoPropertyName"] =
    "StyleSheetPseudoPropertyName";
  ContextTypes1["StyleSheetPseudoPropertyParentheses"] =
    "StyleSheetPseudoPropertyParentheses";
  ContextTypes1["StyleSheetPseudoPropertyItem"] =
    "StyleSheetPseudoPropertyItem";
  ContextTypes1["StyleSheetPseudoPropertyItemName"] =
    "StyleSheetPseudoPropertyItemName";
  ContextTypes1["StyleSheetPseudoPropertyItemValue"] =
    "StyleSheetPseudoPropertyItemValue";
  ContextTypes1["StyleSheetSelector"] = "StyleSheetSelector";
  ContextTypes1["StyleSheetSelectorList"] = "StyleSheetSelectorList";
  ContextTypes1["StyleSheetSelectorHTMLElement"] =
    "StyleSheetSelectorHTMLElement";
  ContextTypes1["StyleSheetSelectorClass"] = "StyleSheetSelectorClass";
  ContextTypes1["StyleSheetSelectorId"] = "StyleSheetSelectorId";
  ContextTypes1["StyleSheetSelectorAttribute"] = "StyleSheetSelectorAttribute";
  ContextTypes1["StyleSheetSelectorAttributeEqual"] =
    "StyleSheetSelectorAttributeEqual";
  ContextTypes1["StyleSheetSelectorAttributeValue"] =
    "StyleSheetSelectorAttributeValue";
  ContextTypes1["StyleSheetSelectorPseudoClass"] =
    "StyleSheetSelectorPseudoClass";
  ContextTypes1["StyleSheetSelectorPseudoElement"] =
    "StyleSheetSelectorPseudoElement";
  ContextTypes1["StyleSheetSelectorCombinatorChildSelector"] =
    "StyleSheetSelectorCombinatorChildSelector";
  ContextTypes1["StyleSheetSelectorCombinatorAdjacentSibling"] =
    "StyleSheetSelectorCombinatorAdjacentSibling";
  ContextTypes1["StyleSheetSelectorCombinatorGeneralSibling"] =
    "StyleSheetSelectorCombinatorGeneralSibling";
  ContextTypes1["StyleSheetSelectorCombinatorAll"] =
    "StyleSheetSelectorCombinatorAll";
  ContextTypes1["StyleSheetHexType"] = "StyleSheetHexType";
  ContextTypes1["StyleSheetPixelType"] = "StyleSheetPixelType";
})(ContextTypes1 || (ContextTypes1 = {}));
var Reason1;
(function (Reason1) {
  Reason1[Reason1["Unsupported"] = 0] = "Unsupported";
  Reason1[Reason1["UnexpectedToken"] = 1436] = "UnexpectedToken";
  Reason1[Reason1["HTMLTagNotClosed"] = 1443] = "HTMLTagNotClosed";
  Reason1[Reason1["CommentBlockOpen"] = 1519] = "CommentBlockOpen";
  Reason1[Reason1["StringSingleQuoteOpen"] = 1593] = "StringSingleQuoteOpen";
  Reason1[Reason1["StringDoubleQuoteOpen"] = 1633] = "StringDoubleQuoteOpen";
  Reason1[Reason1["StringTemplateQuoteOpen"] = 1678] =
    "StringTemplateQuoteOpen";
  Reason1[Reason1["StringTemplateQuoteEvaluationOpen"] = 1725] =
    "StringTemplateQuoteEvaluationOpen";
  Reason1[Reason1["BracesOpen"] = 1773] = "BracesOpen";
  Reason1[Reason1["CurlyBracketsOpen"] = 1819] = "CurlyBracketsOpen";
  Reason1[Reason1["ArrayOpen"] = 1866] = "ArrayOpen";
  Reason1[Reason1["ParentheseOpen"] = 1896] = "ParentheseOpen";
  Reason1[Reason1["HTMLClosingTagWithoutOpening"] = 2116] =
    "HTMLClosingTagWithoutOpening";
  Reason1[Reason1["HTMLTagNotFinish"] = 2128] = "HTMLTagNotFinish";
  Reason1[Reason1["HTMLCommentOpen"] = 2211] = "HTMLCommentOpen";
  Reason1[Reason1["ImportAmbientStringMissing"] = 2274] =
    "ImportAmbientStringMissing";
  Reason1[Reason1["ImportStatementNotFinish"] = 2354] =
    "ImportStatementNotFinish";
  Reason1[Reason1["OgoneFlagNotFinish"] = 2406] = "OgoneFlagNotFinish";
  Reason1[Reason1["OgoneSpreadFlagNotClosed"] = 2491] =
    "OgoneSpreadFlagNotClosed";
  Reason1[Reason1["HTMLAttributeNotClosed"] = 2549] = "HTMLAttributeNotClosed";
  Reason1[Reason1["HTMLBooleanAttributeNotClosed"] = 2590] =
    "HTMLBooleanAttributeNotClosed";
  Reason1[Reason1["HTMLAttributeNameNotClosed"] = 2630] =
    "HTMLAttributeNameNotClosed";
  Reason1[Reason1["HTMLAttributeValueUnquotedNotClosed"] = 2670] =
    "HTMLAttributeValueUnquotedNotClosed";
  Reason1[Reason1["StyleSheetAtRuleCharsetInvalid"] = 2887] =
    "StyleSheetAtRuleCharsetInvalid";
  Reason1[Reason1["StyleSheetAtRuleCharsetStringIsMissing"] = 2890] =
    "StyleSheetAtRuleCharsetStringIsMissing";
  Reason1[Reason1["StyleSheetAtRuleCharsetNotFinish"] = 2894] =
    "StyleSheetAtRuleCharsetNotFinish";
  Reason1[Reason1["StyleSheetAtRuleCurlyBracketsAreMissing"] = 2960] =
    "StyleSheetAtRuleCurlyBracketsAreMissing";
  Reason1[Reason1["StyleSheetTypeAssignmentNotFinish"] = 3004] =
    "StyleSheetTypeAssignmentNotFinish";
  Reason1[Reason1["StyleSheetAttributeNotClosed"] = 3408] =
    "StyleSheetAttributeNotClosed";
  Reason1[Reason1["StyleSheetPropertyListOpen"] = 3533] =
    "StyleSheetPropertyListOpen";
  Reason1[Reason1["StyleSheetRulePropertyValueNotClosed"] = 3764] =
    "StyleSheetRulePropertyValueNotClosed";
  Reason1[Reason1["StyleSheetRuleSpreadNameMissing"] = 3923] =
    "StyleSheetRuleSpreadNameMissing";
  Reason1[Reason1["ComponentDeclarationNodeMissing"] = 4200] =
    "ComponentDeclarationNodeMissing";
  Reason1[Reason1["ModifierNotFinished"] = 4300] = "ModifierNotFinished";
  Reason1[Reason1["AsStatementMissingIdentifier"] = 4301] =
    "AsStatementMissingIdentifier";
  Reason1[Reason1["ComponentNotFound"] = 5000] = "ComponentNotFound";
})(Reason1 || (Reason1 = {}));
const SupportedStyleSheetCharset = [
  "US-ASCII",
  "ISO_8859-1:1987",
  "ISO_8859-2:1987",
  "ISO_8859-3:1988",
  "ISO_8859-4:1988",
  "ISO_8859-5:1988",
  "ISO_8859-6:1987",
  "ISO_8859-7:1987",
  "ISO_8859-8:1988",
  "ISO_8859-9:1989",
  "ISO-8859-10",
  "ISO_6937-2-add",
  "JIS_X0201",
  "JIS_Encoding",
  "Shift_JIS",
  "Extended_UNIX_Code_Packed_Format_for_Japanese",
  "Extended_UNIX_Code_Fixed_Width_for_Japanese",
  "BS_4730",
  "SEN_850200_C",
  "IT",
  "ES",
  "DIN_66003",
  "NS_4551-1",
  "NF_Z_62-010",
  "ISO-10646-UTF-1",
  "ISO_646.basic:1983",
  "INVARIANT",
  "ISO_646.irv:1983",
  "NATS-SEFI",
  "NATS-SEFI-ADD",
  "NATS-DANO",
  "NATS-DANO-ADD",
  "SEN_850200_B",
  "KS_C_5601-1987",
  "ISO-2022-KR",
  "EUC-KR",
  "ISO-2022-JP",
  "ISO-2022-JP-2",
  "JIS_C6220-1969-jp",
  "JIS_C6220-1969-ro",
  "PT",
  "greek7-old",
  "latin-greek",
  "NF_Z_62-010_(1973)",
  "Latin-greek-1",
  "ISO_5427",
  "JIS_C6226-1978",
  "BS_viewdata",
  "INIS",
  "INIS-8",
  "INIS-cyrillic",
  "ISO_5427:1981",
  "ISO_5428:1980",
  "GB_1988-80",
  "GB_2312-80",
  "NS_4551-2",
  "videotex-suppl",
  "PT2",
  "ES2",
  "MSZ_7795.3",
  "JIS_C6226-1983",
  "greek7",
  "ASMO_449",
  "iso-ir-90",
  "JIS_C6229-1984-a",
  "JIS_C6229-1984-b",
  "JIS_C6229-1984-b-add",
  "JIS_C6229-1984-hand",
  "JIS_C6229-1984-hand-add",
  "JIS_C6229-1984-kana",
  "ISO_2033-1983",
  "ANSI_X3.110-1983",
  "T.61-7bit",
  "T.61-8bit",
  "ECMA-cyrillic",
  "CSA_Z243.4-1985-1",
  "CSA_Z243.4-1985-2",
  "CSA_Z243.4-1985-gr",
  "ISO_8859-6-E",
  "ISO_8859-6-I",
  "T.101-G2",
  "ISO_8859-8-E",
  "ISO_8859-8-I",
  "CSN_369103",
  "JUS_I.B1.002",
  "IEC_P27-1",
  "JUS_I.B1.003-serb",
  "JUS_I.B1.003-mac",
  "greek-ccitt",
  "NC_NC00-10:81",
  "ISO_6937-2-25",
  "GOST_19768-74",
  "ISO_8859-supp",
  "ISO_10367-box",
  "latin-lap",
  "JIS_X0212-1990",
  "DS_2089",
  "us-dk",
  "dk-us",
  "KSC5636",
  "UNICODE-1-1-UTF-7",
  "ISO-2022-CN",
  "ISO-2022-CN-EXT",
  "UTF-8",
  "ISO-8859-13",
  "ISO-8859-14",
  "ISO-8859-15",
  "ISO-8859-16",
  "GBK",
  "GB18030",
  "OSD_EBCDIC_DF04_15",
  "OSD_EBCDIC_DF03_IRV",
  "OSD_EBCDIC_DF04_1",
  "ISO-11548-1",
  "KZ-1048",
  "ISO-10646-UCS-2",
  "ISO-10646-UCS-4",
  "ISO-10646-UCS-Basic",
  "ISO-10646-Unicode-Latin1",
  "ISO-10646-J-1",
  "ISO-Unicode-IBM-1261",
  "ISO-Unicode-IBM-1268",
  "ISO-Unicode-IBM-1276",
  "ISO-Unicode-IBM-1264",
  "ISO-Unicode-IBM-1265",
  "UNICODE-1-1",
  "SCSU",
  "UTF-7",
  "UTF-16BE",
  "UTF-16LE",
  "UTF-16",
  "CESU-8",
  "UTF-32",
  "UTF-32BE",
  "UTF-32LE",
  "BOCU-1",
  "UTF-7-IMAP",
  "ISO-8859-1-Windows-3.0-Latin-1",
  "ISO-8859-1-Windows-3.1-Latin-1",
  "ISO-8859-2-Windows-Latin-2",
  "ISO-8859-9-Windows-Latin-5",
  "hp-roman8",
  "Adobe-Standard-Encoding",
  "Ventura-US",
  "Ventura-International",
  "DEC-MCS",
  "IBM850",
  "PC8-Danish-Norwegian",
  "IBM862",
  "PC8-Turkish",
  "IBM-Symbols",
  "IBM-Thai",
  "HP-Legal",
  "HP-Pi-font",
  "HP-Math8",
  "Adobe-Symbol-Encoding",
  "HP-DeskTop",
  "Ventura-Math",
  "Microsoft-Publishing",
  "Windows-31J",
  "GB2312",
  "Big5",
  "macintosh",
  "IBM037",
  "IBM038",
  "IBM273",
  "IBM274",
  "IBM275",
  "IBM277",
  "IBM278",
  "IBM280",
  "IBM281",
  "IBM284",
  "IBM285",
  "IBM290",
  "IBM297",
  "IBM420",
  "IBM423",
  "IBM424",
  "IBM437",
  "IBM500",
  "IBM851",
  "IBM852",
  "IBM855",
  "IBM857",
  "IBM860",
  "IBM861",
  "IBM863",
  "IBM864",
  "IBM865",
  "IBM868",
  "IBM869",
  "IBM870",
  "IBM871",
  "IBM880",
  "IBM891",
  "IBM903",
  "IBM904",
  "IBM905",
  "IBM918",
  "IBM1026",
  "EBCDIC-AT-DE",
  "EBCDIC-AT-DE-A",
  "EBCDIC-CA-FR",
  "EBCDIC-DK-NO",
  "EBCDIC-DK-NO-A",
  "EBCDIC-FI-SE",
  "EBCDIC-FI-SE-A",
  "EBCDIC-FR",
  "EBCDIC-IT",
  "EBCDIC-PT",
  "EBCDIC-ES",
  "EBCDIC-ES-A",
  "EBCDIC-ES-S",
  "EBCDIC-UK",
  "EBCDIC-US",
  "UNKNOWN-8BIT",
  "MNEMONIC",
  "MNEM",
  "VISCII",
  "VIQR",
  "KOI8-R",
  "HZ-GB-2312",
  "IBM866",
  "IBM775",
  "KOI8-U",
  "IBM00858",
  "IBM00924",
  "IBM01140",
  "IBM01141",
  "IBM01142",
  "IBM01143",
  "IBM01144",
  "IBM01145",
  "IBM01146",
  "IBM01147",
  "IBM01148",
  "IBM01149",
  "Big5-HKSCS",
  "IBM1047",
  "PTCP154",
  "Amiga-1251",
  "KOI7-switched",
  "BRF",
  "TSCII",
  "CP51932",
  "windows-874",
  "windows-1250",
  "windows-1251",
  "windows-1252",
  "windows-1253",
  "windows-1254",
  "windows-1255",
  "windows-1256",
  "windows-1257",
  "windows-1258",
  "TIS-620",
  "CP50220",
  "Alexander Uskov",
  "Alexei Veremeev",
  "Chris Wendt",
  "Florian Weimer",
  "Hank Nussbacher",
  "Internet Assigned Numbers Authority",
  "Jun Murai",
  "Katya Lazhintseva",
  "Keld Simonsen",
  "Keld Simonsen",
  "Kuppuswamy Kalyanasundaram",
  "Mark Davis",
  "Markus Scherer",
  "Masataka Ohta",
  "Nicky Yick",
  "Reuel Robrigado",
  "Rick Pond",
  "Sairan M. Kikkarin",
  "Samuel Thibault",
  "Shawn Steele",
  "Tamer Mahdi",
  "Toby Phipps",
  "Trin Tantsetthi",
  "Vladas Tumasonis",
  "Woohyong Choi",
  "Yui Naruse",
];
class ExiumContext1 {
  type;
  source;
  start;
  id = 0;
  document;
  #_name;
  #_template;
  #_proto;
  #_protocol;
  #_value;
  children = [];
  related = [];
  data = {};
  constructor(type, source1, start) {
    this.type = type;
    this.source = source1;
    this.start = start;
  }
  get end() {
    return this.start + this.source.length;
  }
  get value() {
    if (this.#_value) return this.#_value;
    const attributeValue = this.children.find((context) =>
      [
        ContextTypes1.Braces,
        ContextTypes1.StringDoubleQuote,
        ContextTypes1.StringSingleQuote,
        ContextTypes1.CurlyBrackets,
        ContextTypes1.AttributeValueUnquoted,
      ].includes(context.type)
    );
    switch (this.type) {
      case ContextTypes1.Braces:
      case ContextTypes1.CurlyBrackets:
      case ContextTypes1.Parenthese:
      case ContextTypes1.StringDoubleQuote:
      case ContextTypes1.StringSingleQuote:
        return this.#_value = this.source.slice(1, -1);
      case ContextTypes1.AttributeValueUnquoted:
      case ContextTypes1.TextNode:
        return this.source;
      case ContextTypes1.Attribute:
      case ContextTypes1.Flag:
      case ContextTypes1.FlagStruct:
        return attributeValue?.value || "";
      case ContextTypes1.Argument:
        return this.name;
      case ContextTypes1.AttributeBoolean:
        return "";
      case ContextTypes1.StyleSheetProperty: {
        const valueCTX = this.related.find((context) =>
          context.type === ContextTypes1.StyleSheetPropertyValue
        );
        return valueCTX?.value || "";
      }
      case ContextTypes1.StyleSheetPropertyValue:
        return this.source;
    }
    return "";
  }
  get name() {
    if (this.#_name) return this.#_name;
    if (this.type === ContextTypes1.ComponentDeclaration) {
      const ctx = this.children.find((ctx1) =>
        ctx1.type === ContextTypes1.Node
      );
      return this.#_name = ctx?.name;
    }
    const ctx = this.related.find((ctx1) =>
      ctx1.type === ContextTypes1.Identifier
    );
    return this.#_name = ctx?.source;
  }
  get nodeType() {
    switch (this.type) {
      case ContextTypes1.Node:
        return 1;
      case ContextTypes1.NodeClosing:
        return 1;
      case ContextTypes1.Attribute:
        return 2;
      case ContextTypes1.AttributeBoolean:
        return 2;
      case ContextTypes1.Flag:
        return 2;
      case ContextTypes1.FlagStruct:
        return 2;
      case ContextTypes1.TextNode:
        return 3;
      case ContextTypes1.Protocol:
        return 3;
      case ContextTypes1.StyleSheet:
        return 9;
    }
    return 6;
  }
  get nodeStart() {
    return this.start;
  }
  get nodeEnd() {
    const nodeEnd = this.related.find((context) =>
      context.type === ContextTypes1.NodeClosing
    );
    if (nodeEnd) return nodeEnd.end;
    return this.end;
  }
  get parentNode() {
    return this.data.parentNode;
  }
  get template() {
    return !this.parentNode && this.nodeType === 1 ||
        this.type === ContextTypes1.ComponentDeclaration
      ? this.#_template ||
        (this.#_template = this.children.find((context) =>
          context.type === ContextTypes1.Node && !context.data.isNodeClosing &&
          context.name === "template"
        ))
      : undefined;
  }
  get proto() {
    return !this.parentNode && this.nodeType === 1
      ? this.#_proto ||
        (this.#_proto = this.children.find((context) =>
          context.type === ContextTypes1.Node && !context.data.isNodeClosing &&
          context.name === "proto"
        ))
      : undefined;
  }
  get protocol() {
    if (!this.proto) return null;
    return this.#_protocol ||
      (this.#_protocol = this.#getDeepElement((context) =>
        context.type === ContextTypes1.Protocol
      ));
  }
  get cssProperties() {
    switch (this.type) {
      case ContextTypes1.StyleSheetSelectorList:
        const { cssList } = this;
        return cssList?.cssProperties || null;
      case ContextTypes1.StyleSheetPropertyList:
        return this.children.filter((context) =>
          context.type === ContextTypes1.StyleSheetProperty
        );
      default:
        return null;
    }
  }
  get cssList() {
    switch (this.type) {
      case ContextTypes1.StyleSheetSelectorList:
        return this.related.find((context) =>
          context.type === ContextTypes1.StyleSheetPropertyList
        );
    }
  }
  #getDeepElement(search) {
    let result = this.children.find(search);
    if (!result) {
      this.children.forEach((context) => {
        if (!result) {
          result = context.#getDeepElement(search);
        }
      });
    }
    return result;
  }
  #getDeepElements(search) {
    const result = [
      ...this.related.filter(search),
    ];
    this.children.forEach((context) => {
      result.push(...context.#getDeepElements(search));
    });
    return result;
  }
  getImportPath() {
    switch (this.type) {
      case ContextTypes1.ImportAmbient:
      case ContextTypes1.ImportStatement:
        {
          const str = this.related.find((context) =>
            [
              ContextTypes1.StringDoubleQuote,
              ContextTypes1.StringSingleQuote,
            ].includes(context.type)
          );
          if (str) return str.value;
        }
        break;
      default: {
        return null;
      }
    }
    return null;
  }
  getPosition(content) {
    let line = 0;
    let column = 0;
    let x = 0;
    for (const __char of content) {
      if (x >= this.start) break;
      if (__char === "\n") {
        line++;
        column = 0;
      } else {
        column++;
      }
      x++;
    }
    return {
      line,
      column,
      start: this.start,
      end: this.start + this.source.length,
    };
  }
  getAttributeContext(attribute) {
    const attr = this.children.find((context) =>
      [
        ContextTypes1.Attribute,
        ContextTypes1.AttributeBoolean,
      ].includes(context.type) && context.name === attribute
    );
    return attr;
  }
  getAttribute(attribute) {
    const attr = this.getAttributeContext(attribute);
    if (!attr) return;
    return attr.value;
  }
  getFlagContext(name) {
    if (this.type !== ContextTypes1.Node) {
      throw new Error(
        `getFlagContext is not allowed with this context. context's type has to be ${ContextTypes1.Node}`,
      );
    }
    return this.children.find((context) =>
      [
        ContextTypes1.Flag,
        ContextTypes1.FlagStruct,
      ].includes(context.type) && context.name === name
    );
  }
  getArguments() {
    return this.children.filter((context) =>
      context.type === ContextTypes1.Argument
    );
  }
  getPropertyContexts(name) {
    switch (this.type) {
      case ContextTypes1.StyleSheetSelectorList: {
        const propertyList = this.related.find((context) =>
          context.type === ContextTypes1.StyleSheetPropertyList
        );
        if (!propertyList) return [];
        const properties = propertyList.children.filter((context) =>
          context.type === ContextTypes1.StyleSheetProperty &&
          context.name === name
        );
        return properties;
      }
      default:
        return [];
    }
  }
  getStylesheetRulesByTagName(tagname) {
    if (!this.document) return [];
    return this.document.contexts.filter((child) => {
      return child.type === ContextTypes1.StyleSheetSelectorList &&
        child.start >= this.nodeStart && child.end <= this.nodeEnd &&
        child.children.find((subchild) =>
          subchild.type === ContextTypes1.StyleSheetSelectorHTMLElement &&
          subchild.source === tagname
        );
    });
  }
  getStylesheetRulesByClassName(className) {
    if (!this.document) return [];
    return this.document.contexts.filter((child) => {
      return child.type === ContextTypes1.StyleSheetSelectorList &&
        child.start >= this.nodeStart && child.end <= this.nodeEnd &&
        child.children.find((subchild) =>
          subchild.type === ContextTypes1.StyleSheetSelectorClass &&
          subchild.source === `.${className}`
        );
    });
  }
  getStylesheetRulesById(id) {
    if (!this.document) return [];
    return this.document.contexts.filter((child) => {
      return child.type === ContextTypes1.StyleSheetSelectorList &&
        child.start >= this.nodeStart && child.end <= this.nodeEnd &&
        child.children.find((subchild) =>
          subchild.type === ContextTypes1.StyleSheetSelectorId &&
          subchild.source === `#${id}`
        );
    });
  }
  getStylesheetRulesByAttribute(attr) {
    if (!this.document) return [];
    return this.document.contexts.filter((child) => {
      return child.type === ContextTypes1.StyleSheetSelectorList &&
        child.start >= this.nodeStart && child.end <= this.nodeEnd &&
        child.children.find((subchild) =>
          subchild.type === ContextTypes1.StyleSheetSelectorAttribute &&
          subchild.name === attr
        );
    });
  }
  getStylesheetRulesByProperty(property, value) {
    if (!this.document) return [];
    return this.document.contexts.filter((child) => {
      return child.type === ContextTypes1.StyleSheetSelectorList &&
        child.start >= this.nodeStart && child.end <= this.nodeEnd &&
        child.related.find((subchild) =>
          subchild.type === ContextTypes1.StyleSheetPropertyList &&
          subchild.children.find((props) =>
            !value && props.type === ContextTypes1.StyleSheetProperty &&
              props.name === property ||
            value && props.type === ContextTypes1.StyleSheetProperty &&
              props.name === property && props.related.find((propValue) =>
                propValue.type === ContextTypes1.StyleSheetPropertyValue &&
                propValue.source.trim() === value
              )
          )
        );
    });
  }
  getStylesheetRulesByPseudoProperty(property) {
    if (!this.document) return [];
    return this.document.contexts.filter((child) => {
      return child.type === ContextTypes1.StyleSheetSelectorList &&
        child.start >= this.nodeStart && child.end <= this.nodeEnd &&
        child.related.find((subchild) =>
          subchild.type === ContextTypes1.StyleSheetPropertyList &&
          subchild.children.find((props) => {
            return props.type === ContextTypes1.StyleSheetPseudoProperty &&
              props.name === property;
          })
        );
    });
  }
  getStylesheetConstants() {
    if (!this.document) return [];
    return this.document.contexts.filter((context) => {
      return context.type === ContextTypes1.StyleSheetAtRuleConst &&
        context.start >= this.nodeStart && context.end <= this.nodeEnd;
    });
  }
  getStylesheetExportedConstants() {
    if (!this.document) return [];
    const exports = this.document.contexts.filter((context) => {
      return context.type === ContextTypes1.StyleSheetAtRuleExport &&
        context.start >= this.nodeStart && context.end <= this.nodeEnd;
    });
    const isConst = exports.filter((exp) =>
      exp.children.find((child) =>
        child.type === ContextTypes1.StyleSheetAtRuleConst
      )
    );
    return isConst.map((exp) =>
      exp.children.find((child) =>
        child.type === ContextTypes1.StyleSheetAtRuleConst
      )
    );
  }
  getStylesheetConstant(name) {
    if (!this.document) return;
    return this.document.contexts.find((context) => {
      return context.type === ContextTypes1.StyleSheetAtRuleConst &&
        context.start >= this.nodeStart && context.end <= this.nodeEnd &&
        context.name === name;
    });
  }
  getStylesheetExportedConstant(name) {
    if (!this.document) return;
    const exportCTX = this.document.contexts.find((context) => {
      return context.type === ContextTypes1.StyleSheetAtRuleExport &&
        context.start >= this.nodeStart && context.end <= this.nodeEnd;
    });
    if (!exportCTX) return;
    return exportCTX.children.find((child) =>
      child.type === ContextTypes1.StyleSheetAtRuleConst && child.name === name
    );
  }
  getImportedIdentifiers() {
    if (this.type !== ContextTypes1.ImportStatement) return null;
    const identifierList = this.children.find((context) =>
      context.type === ContextTypes1.IdentifierList
    );
    if (identifierList) {
      return identifierList.children.filter((context) =>
        context.type === ContextTypes1.Identifier
      );
    }
    const identifier = this.children.find((context) =>
      context.type === ContextTypes1.Identifier
    );
    if (identifier) {
      return [
        identifier,
      ];
    }
    return null;
  }
  getNodeInnerTextWithSource(source) {
    const nodeEnd = this.related.find((context) =>
      context.type === ContextTypes1.NodeClosing
    );
    if (this.nodeType === 1 && nodeEnd) {
      const { end } = this;
      const { start: start1 } = nodeEnd;
      return source.slice(end, start1);
    }
    return null;
  }
  getNodeInnerTextWithInternalDocument() {
    const { document } = this;
    if (!document) {
      throw new Error(
        "cannot use getNodeInnerTextWithInternalDocument because this context is not retrieved with an ExiumDocument.",
      );
    }
    const source2 = document.getText();
    const nodeEnd = this.related.find((context) =>
      context.type === ContextTypes1.NodeClosing
    );
    if (this.nodeType === 1 && nodeEnd) {
      const { end } = this;
      const { start: start1 } = nodeEnd;
      return source2.slice(end, start1);
    }
    return null;
  }
  getNodeInnerTextWithExternalDocument(document) {
    if (!document || !(document instanceof ExiumDocument1)) {
      throw new Error(
        "missing first argument, getNodeInnerTextWithExternalDocument is waiting for an ExiumDocument.",
      );
    }
    const source2 = document.getText();
    const nodeEnd = this.related.find((context) =>
      context.type === ContextTypes1.NodeClosing
    );
    if (this.nodeType === 1 && nodeEnd) {
      const { end } = this;
      const { start: start1 } = nodeEnd;
      return source2.slice(end, start1);
    }
    return null;
  }
  getAttributeModifiers(name) {
    switch (this.type) {
      case ContextTypes1.Node:
        const modifier = this.children.filter((context) =>
          context.type === ContextTypes1.AttributeModifier &&
          context.name === name
        );
        return modifier || null;
      case ContextTypes1.ComponentDeclaration:
        const node = this.children.find((context) =>
          context.type === ContextTypes1.Node && !context.data.isNodeClosing
        );
        if (node) {
          const modifier1 = node.children.filter((context) =>
            context.type === ContextTypes1.AttributeModifier &&
            context.name === name
          );
          return modifier1 || null;
        } else return null;
      default:
        return null;
    }
  }
}
const importRegExp = /^import\b/i;
const importComponentRegExp = /^import\s+component\b/i;
const asRegExp = /^\s+as/i;
const supportedComponentTypes = [
  "component",
  "app",
  "async",
  "router",
  "store",
  "controller",
  "gl",
];
const checkOnlyOptions = {
  checkOnly: true,
};
function getChar(exium) {
  return exium.source[exium.cursor.x];
}
function getCharCode(exium) {
  return getChar(exium)?.charCodeAt(0);
}
function isCharPuntuation(exium) {
  const code = getCharCode(exium);
  return code >= 123 && code <= 124 || code >= 91 && code <= 96 ||
    code >= 58 && code <= 64 || code >= 32 && code <= 47;
}
function isCharDigit(exium) {
  if (isCharSpacing(exium)) return false;
  const code = getCharCode(exium);
  return code >= 48 && code <= 57;
}
function isCharIdentifier(exium) {
  if (isCharSpacing(exium)) return false;
  const code = getCharCode(exium);
  return code >= 65 && code <= 90 || code === 36 || code === 95 ||
    code >= 97 && code <= 122;
}
function isCharSpacing(exium) {
  const code = getCharCode(exium);
  return code === 9 || code === 10 || code === 13 || code === 32;
}
function getPrev(exium) {
  return exium.source[exium.cursor.x - 1];
}
function getNextPart(exium) {
  return exium.source.slice(exium.cursor.x);
}
function getPreviousPart(exium) {
  return exium.source.slice(0, exium.cursor.x);
}
function getNext(exium) {
  return exium.source[exium.cursor.x + 1];
}
function isParsingStylesheet(exium) {
  return Boolean(
    exium.parseOptions && exium.parseOptions.type === "stylesheet",
  );
}
function getNodeContextStarted(exium) {
  return Boolean(exium.currentContexts.find((context) =>
    [
      ContextTypes1.Node,
    ].includes(context.type)
  ));
}
function debugg(exium, ...args) {
  if (exium.parseOptions?.debugg) {
    console.log(...args);
  }
}
function debuggPosition(exium, name) {
  if (exium.parseOptions?.debugg) {
    debugg(exium, `${exium.cursor.x} - %c${name.trim()}`, "color:orange", {
      prev: getPrev(exium),
      char: getChar(exium),
      next: getNext(exium),
    });
  }
}
function readExportComponentStatementsCtx(exium) {
  try {
    const isValid = readIdentifierCtx(exium, checkOnlyOptions);
    if (!isValid) return false;
    const recognized = readIdentifierCtx(exium);
    if (!recognized) return false;
    const lastContext = getLastContext(exium);
    const { x } = exium.cursor;
    if (lastContext.source !== "export") {
      shift(exium, -lastContext.source.length);
      return false;
    }
    let isClosed = false;
    const allSubs = [
      readMultiSpacesCtx,
      readSpaceCtx,
      readComponentCtx,
    ];
    const children = [];
    while (!isEOF(exium)) {
      saveStrictContextsTo(exium, allSubs, children);
      const foundComponent = children.find((context) =>
        context.type === ContextTypes1.ComponentDeclaration
      );
      if (foundComponent) {
        isClosed = true;
        foundComponent.data.isExported = true;
        break;
      }
      if (isCharSpacing(exium)) {
        break;
      }
    }
    const context = new ExiumContext1(
      ContextTypes1.ExportStatement,
      lastContext.source,
      x,
    );
    context.related.push(lastContext);
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(
        Reason1.UnexpectedToken,
        exium.cursor,
        getUnexpected(exium),
      );
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readComponentCtx(exium, opts) {
  try {
    const { x } = exium.cursor;
    const isValid = readIdentifierCtx(exium, checkOnlyOptions);
    if (!isValid) return false;
    const recognized = readIdentifierCtx(exium);
    if (!recognized) return false;
    const lastContext = getLastContext(exium);
    if (!supportedComponentTypes.includes(lastContext.source)) {
      return false;
    }
    if (opts?.checkOnly) return true;
    const { source: source2 } = exium;
    lastContext.type = ContextTypes1.ComponentTypeStatement;
    let isNodeDefined = false;
    const allSubContexts = [
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readTextnodeCtx,
      readNodeCtx,
      readNodeCtx,
    ];
    const children = [];
    while (!isEOF(exium)) {
      saveContextsTo(exium, allSubContexts, children);
      const node = children.find((context) =>
        context.type === ContextTypes1.Node && context.related.find((child) =>
            child.type === ContextTypes1.NodeClosing
          ) &&
          !context.data.parentNode && !context.data.isAutoClosing ||
        context.type === ContextTypes1.Node && context.data.isAutoClosing &&
          !context.data.parentNode
      );
      if (node) {
        isNodeDefined = true;
        break;
      }
      shift(exium, 1);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.ComponentDeclaration,
      token,
      x,
    );
    context.children.push(...children);
    Object.assign(context.data, {
      type: lastContext.source,
    });
    exium.currentContexts.push(context);
    if (!isNodeDefined) {
      exium.onError(
        Reason1.ComponentDeclarationNodeMissing,
        exium.cursor,
        context,
      );
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readAttributesModifiersCtx(exium, opts) {
  try {
    const __char = getChar(exium);
    const { x } = exium.cursor;
    const isValid = __char === "@";
    if (!isValid) return false;
    if (opts?.checkOnly) return true;
    shift(exium, 1);
    if (!readIdentifierCtx(exium, checkOnlyOptions)) {
      shift(exium, -1);
      return false;
    }
    const { source: source2, cursor } = exium;
    const attributes = [
      ContextTypes1.Attribute,
      ContextTypes1.AttributeBoolean,
      ContextTypes1.AttributeProperty,
    ];
    const exitChars = [
      " ",
      ">",
      "\n",
      "/",
      "@",
    ];
    let isIdentified = false;
    let isCompleted = false;
    const related = [];
    const children = [];
    const definitions = [
      readIdentifierCtx,
      readArgumentCtx,
      readArrayCtx,
    ];
    const allSubContexts = [
      readMultiSpacesCtx,
      readSpaceCtx,
      readLineBreakCtx,
      readAttributesCtx,
    ];
    while (!isEOF(exium)) {
      if (!isIdentified) {
        saveStrictContextsTo(exium, definitions, related);
        isIdentified = Boolean(
          related.find((context) => context.type === ContextTypes1.Identifier),
        );
        const array = isIdentified &&
          related.find((context) => context.type === ContextTypes1.Array);
        if (array) {
          array.type = ContextTypes1.AttributeModifierType;
        }
        const argument = isIdentified &&
          related.find((context) => context.type === ContextTypes1.Argument);
        if (argument) {
          children.push(argument);
        }
      } else {
        saveContextsTo(exium, allSubContexts, children);
        const attribute = children.find((context) =>
          attributes.includes(context.type)
        );
        if (attribute) {
          isCompleted = true;
          break;
        }
        if (exitChars.includes(getChar(exium)) || isCharSpacing(exium)) {
          break;
        }
      }
      isValidChar(exium, opts?.unexpected);
      shift(exium, 1);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.AttributeModifier,
      token,
      x,
    );
    context.related.push(...related);
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isCompleted) {
      exium.onError(Reason1.ModifierNotFinished, cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readAttributeUnquotedCtx(exium, opts) {
  try {
    const prev = getPrev(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    if (prev !== "=") return false;
    if (opts?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    const children = [];
    const exitChars = [
      " ",
      ">",
      "\n",
      "/",
    ];
    while (!isEOF(exium)) {
      isValidChar(
        exium,
        opts?.unexpected || [
          readArrayCtx,
          readBracesCtx,
          readCurlyBracketsCtx,
        ],
      );
      if (exitChars.includes(getChar(exium))) {
        isClosed = true;
        break;
      }
      shift(exium, 1);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.AttributeValueUnquoted,
      token,
      x,
    );
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(
        Reason1.HTMLAttributeValueUnquotedNotClosed,
        exium.cursor,
        context,
      );
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readAttributesCtx(exium, opts) {
  try {
    const __char = getChar(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    if (__char && !/[a-zA-Z0-9\$\_]/i.test(__char)) {
      return false;
    }
    debuggPosition(exium, "ATTRIBUTES CTX START");
    if (opts?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    let isNamed = false;
    let isBoolean = true;
    let isProp = false;
    const children = [];
    const related = [];
    const allSubContexts = [
      readStringDoubleQuoteCtx,
      readStringSingleQuoteCtx,
      readStringTemplateQuoteCtx,
      readCurlyBracketsCtx,
      readAttributeUnquotedCtx,
    ];
    if (!isNamed) {
      isNamed = Boolean(
        readIdentifierCtx(exium) && related.push(getLastContext(exium)),
      );
    }
    const exitChars = [
      " ",
      ">",
      "\n",
      "/",
    ];
    while (!isEOF(exium)) {
      debuggPosition(exium, "ATTRIBUTES CTX");
      isValidChar(exium, opts?.unexpected);
      if (isBoolean) {
        isBoolean = getChar(exium) !== "=";
      }
      saveContextsTo(exium, allSubContexts, children);
      if (!isProp && !isBoolean) {
        isProp = Boolean(
          children.find((context) =>
            context.type === ContextTypes1.CurlyBrackets
          ),
        );
      }
      if (exitChars.includes(getChar(exium))) {
        isClosed = true;
        break;
      }
      shift(exium, 1);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      isBoolean
        ? ContextTypes1.AttributeBoolean
        : isProp
        ? ContextTypes1.AttributeProperty
        : ContextTypes1.Attribute,
      token,
      x,
    );
    context.children.push(...children);
    context.related.push(...related);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.HTMLAttributeNotClosed, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readFlagSpreadCtx(exium, opts) {
  try {
    const __char = getChar(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    if (__char !== "{" || !/^\{(\s*)(\.){3}/i.test(getNextPart(exium))) {
      return false;
    }
    if (opts?.checkOnly) return true;
    shift(exium, 1);
    const result = true;
    let isClosed = false;
    const children = [];
    const readers = [
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readArrayCtx,
      readCurlyBracketsCtx,
    ];
    while (!isEOF(exium)) {
      isValidChar(exium, opts?.unexpected);
      saveContextsTo(exium, readers, children);
      if (
        [
          "}",
        ].includes(getChar(exium))
      ) {
        shift(exium, 1);
        isClosed = true;
        break;
      }
      shift(exium, 1);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.FlagSpread, token, x);
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.OgoneSpreadFlagNotClosed, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readFlagCtx(exium, opts) {
  try {
    const __char = getChar(exium);
    const next = getNext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    if (__char !== "-" || next !== "-") return false;
    if (opts?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    let isNamed = false;
    let usingStructure = true;
    let isStructure = false;
    const children = [];
    const related = [];
    const allSubContexts = [
      readCurlyBracketsCtx,
      readArgumentCtx,
      readBracesCtx,
    ];
    const exitChars = [
      " ",
      ">",
      "\n",
      "/",
    ];
    const argumentChar = ":";
    while (!isEOF(exium)) {
      if (!isNamed) {
        isNamed = Boolean(
          readIdentifierCtx(exium, {
            data: {
              allowedIdentifierChars: [
                "-",
              ],
            },
          }) && related.push(getLastContext(exium)),
        );
      }
      if (getChar(exium) === "=") {
        isStructure = false;
        usingStructure = false;
      }
      saveContextsTo(exium, allSubContexts, children, {
        data: {
          readArgumentCtx_starts_with: argumentChar,
        },
      });
      if (isNamed && usingStructure && !isStructure) {
        isStructure = Boolean(
          children.find((context) => context.type === ContextTypes1.Braces),
        );
      }
      if (exitChars.includes(getChar(exium))) {
        isClosed = true;
        break;
      }
      if (getChar(exium) !== argumentChar) {
        shift(exium, 1);
      }
      isValidChar(exium, opts?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      isStructure ? ContextTypes1.FlagStruct : ContextTypes1.Flag,
      token,
      x,
    );
    Object.assign(context.data, {
      isStructure,
    });
    context.children.push(...children);
    context.related.push(...related);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.OgoneFlagNotFinish, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readHTMLCommentCtx(exium, opts) {
  try {
    const __char = getChar(exium);
    const next = getNext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const sequence = [
      __char,
      next,
      source2[x + 2],
      source2[x + 3],
    ];
    if (__char !== "<" || sequence.join("") !== "<!--") {
      return false;
    }
    if (opts?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    const children = [];
    while (!isEOF(exium)) {
      shift(exium, 1);
      isValidChar(
        exium,
        opts?.unexpected || [
          readHTMLCommentCtx,
        ],
      );
      if (
        getChar(exium) === ">" && getPrev(exium) === "-" &&
        source2[exium.cursor.x - 2] === "-"
      ) {
        shift(exium, 1);
        isClosed = true;
        break;
      }
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.HTMLComment, token, x);
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.HTMLCommentOpen, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readNodeCtx(exium, opts) {
  try {
    const __char = getChar(exium);
    const nextPart = getNextPart(exium);
    const next = getNext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    if (
      __char !== "<" || __char === "<" && [
          " ",
          "<",
          "!",
        ].includes(next) ||
      next && /([^a-zA-Z0-9\[\/])/i.test(next)
    ) {
      return false;
    }
    debuggPosition(exium, "NODE CTX START");
    if (opts?.checkOnly) return true;
    shift(exium, 1);
    const result = true;
    let isClosed = false;
    let isAutoClosing = false;
    let isNamed = false;
    let isProto = false;
    let isTemplate = false;
    let isStyle = false;
    const isNodeClosing = nextPart.startsWith("</");
    const subcontextEvaluatedOnce = [
      readIdentifierCtx,
    ];
    const allSubContexts = isNodeClosing
      ? [
        readLineBreakCtx,
        readSpaceCtx,
        readMultiSpacesCtx,
      ]
      : [
        readLineBreakCtx,
        readSpaceCtx,
        readMultiSpacesCtx,
        readFlagSpreadCtx,
        readAttributesCtx,
        readAttributesModifiersCtx,
        readFlagCtx,
      ];
    const children = [];
    const related = [];
    while (!isEOF(exium)) {
      debuggPosition(exium, "NODE CTX");
      isValidChar(
        exium,
        opts?.unexpected || [
          readNodeCtx,
          readHTMLCommentCtx,
        ],
      );
      if (!isNamed) {
        subcontextEvaluatedOnce.forEach((reader) => {
          const recognized = reader(exium);
          if (recognized) {
            const context = getLastContext(exium);
            related.push(context);
            isNamed = context.type === ContextTypes1.Identifier;
            isProto = isNamed && context.source === "proto";
            isTemplate = isNamed && context.source === "template";
            isStyle = isNamed && context.source === "style";
          }
        });
      }
      saveContextsTo(exium, allSubContexts, children);
      if (
        isNodeClosing && isNamed && ![
          " ",
          ">",
          "\n",
        ].includes(getChar(exium))
      ) {
        const token = source2.slice(x, exium.cursor.x);
        const context = new ExiumContext1(ContextTypes1.Unexpected, token, x);
        exium.onError(Reason1.UnexpectedToken, exium.cursor, context);
      }
      if (getChar(exium) === "<") {
        break;
      } else if (getChar(exium) === ">") {
        shift(exium, 1);
        isClosed = true;
        isAutoClosing = getPreviousPart(exium).endsWith("/>");
        break;
      }
      shift(exium, 1);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      isNodeClosing ? ContextTypes1.NodeClosing : ContextTypes1.Node,
      token,
      x,
    );
    context.children.push(...children);
    context.related.push(...related);
    Object.assign(context.data, {
      isTemplate,
      isProto,
      isStyle,
      isAutoClosing,
      isNodeClosing,
      parentNode: exium.openTags[exium.openTags.length - 1],
    });
    exium.currentContexts.push(context);
    if (!isAutoClosing) {
      if (isClosed && !isNodeClosing) {
        exium.openTags.push(context);
      } else if (isClosed && isNodeClosing) {
        const openTag = exium.openTags.slice().reverse().find((nodeContext) => {
          const name = nodeContext.related.find((related1) =>
            related1.type === ContextTypes1.Identifier
          );
          const targetName = context.related.find((related1) =>
            related1.type === ContextTypes1.Identifier
          );
          return name && targetName && !nodeContext.data.closed &&
            name.type === ContextTypes1.Identifier &&
            name.source === targetName.source;
        });
        if (!openTag) {
          exium.onError(
            Reason1.HTMLClosingTagWithoutOpening,
            exium.cursor,
            context,
          );
        } else {
          const index = exium.openTags.indexOf(openTag);
          exium.openTags.splice(index, 1);
          openTag.related.push(context);
          openTag.data.closed = true;
        }
      }
    }
    if (!isClosed) {
      exium.onError(Reason1.HTMLTagNotFinish, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readTextnodeCtx(exium, opts) {
  try {
    const __char = getChar(exium);
    const prev = getPrev(exium);
    const lastContext = getLastContext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const lastIsANode = Boolean(
      lastContext && [
        ContextTypes1.Node,
        ContextTypes1.NodeClosing,
        ContextTypes1.HTMLComment,
      ].includes(lastContext.type),
    );
    const isValid = prev && [
          ">",
        ].includes(prev) &&
        lastIsANode ||
      __char !== "<" && !readImportStatementsCtx(exium, checkOnlyOptions) &&
        !readNodeCtx(exium, checkOnlyOptions) &&
        !readCommentCtx(exium, checkOnlyOptions);
    if (!isValid || !getNodeContextStarted(exium)) return false;
    if (opts?.checkOnly) return true;
    const styleNode = exium.openTags[exium.openTags.length - 1];
    const isStyleNode = styleNode && styleNode.name === "style";
    if (isStyleNode) return readStyleSheetCtx(exium, opts);
    const result = true;
    const children = [];
    const allSubContexts = [
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readStringTemplateQuoteEvalCtx,
    ];
    while (!isEOF(exium)) {
      isValidChar(exium, opts?.unexpected);
      saveContextsTo(exium, allSubContexts, children);
      if (isStartingNode(exium)) {
        break;
      }
      shift(exium, 1);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.TextNode, token, x);
    Object.assign(context.data, {
      parentNode: exium.openTags[exium.openTags.length - 1],
    });
    context.children.push(...children);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function isStartingNode(exium) {
  return [
    "<",
  ].includes(getChar(exium)) &&
    (readNodeCtx(exium, checkOnlyOptions) ||
      readHTMLCommentCtx(exium, checkOnlyOptions));
}
function isEndOfStylesheet(exium) {
  const nextPart = getNextPart(exium);
  return isStartingNode(exium) && nextPart.startsWith("</style") ||
    isEOF(exium) || /\s*(\<\/style)/i.test(nextPart);
}
function isValidChar(exium, unexpected) {
  if (!unexpected) return;
  for (const reader of unexpected) {
    const isUnexpected = reader(exium, checkOnlyOptions);
    if (isUnexpected) {
      exium.onError(
        Reason1.UnexpectedToken,
        exium.cursor,
        getLastContext(exium),
      );
    }
  }
}
function saveContextsTo(exium, fromContexts, to, opts) {
  let endingCTX = false;
  exium.treePosition++;
  for (const reader of fromContexts) {
    debugg(
      exium,
      `${"\t".repeat(exium.treePosition)}%c[${getChar(exium)}]`,
      "color:yellow",
    );
    const recognized = reader(exium, opts || {});
    if (recognized === null) {
      to.push(getLastContext(exium));
      fromContexts.splice(0);
      endingCTX = true;
      break;
    }
    if (recognized) {
      debugg(
        exium,
        `\n\t\t\t%cusing reader: ${reader.name} was sucessful\n`,
        "color:gray",
      );
      to.push(getLastContext(exium));
    }
  }
  exium.treePosition--;
  if (endingCTX) return;
}
function saveStrictContextsTo(exium, fromContexts, to, opts) {
  const { length } = to;
  let endingCTX = false;
  exium.treePosition++;
  for (const reader of fromContexts) {
    debugg(
      exium,
      `${"\t".repeat(exium.treePosition)}%c[${getChar(exium)}]`,
      "color:yellow",
    );
    const recognized = reader(exium, opts || {});
    if (recognized === null) {
      to.push(getLastContext(exium));
      fromContexts.splice(0);
      endingCTX = true;
      break;
    }
    if (recognized) {
      debugg(
        exium,
        `\n\t\t\t%cusing reader: ${reader.name} was sucessful\n`,
        "color:gray",
      );
      to.push(getLastContext(exium));
    }
  }
  exium.treePosition--;
  if (endingCTX) return;
  if (to.length === length && !isEOF(exium)) {
    exium.onError(Reason1.UnexpectedToken, exium.cursor, getUnexpected(exium));
  }
}
function shift(exium, movement = 1) {
  exium.cursor.x += +movement;
  debugg(
    exium,
    `%c\t\t${movement} ${getPrev(exium)} ${
      ">".repeat(movement > 0 ? movement : 0)
    } ${getChar(exium)}`,
    "color:gray",
  );
}
function shiftUntilEndOf(exium, text) {
  if (!getNextPart(exium).startsWith(text)) return false;
  let result = "";
  while (result !== text) {
    result += getChar(exium);
    shift(exium, 1);
  }
  return true;
}
function saveToken(exium, token, type1) {
  const { x } = exium.cursor;
  const hasShifted = shiftUntilEndOf(exium, token);
  if (hasShifted) {
    const context = new ExiumContext1(type1, token, x);
    exium.currentContexts.push(context);
    return context;
  }
}
function isFollowedBy(exium, text, shiftToTheEnd) {
  const nextPart = getNextPart(exium);
  const result = nextPart.startsWith(text);
  if (shiftToTheEnd && result) {
    shiftUntilEndOf(exium, text);
  }
  return result;
}
function getUnexpected(exium) {
  return new ExiumContext1(
    ContextTypes1.Unexpected,
    exium.source.slice(exium.cursor.x),
    exium.cursor.x,
  );
}
function getLastContext(exium) {
  const last = exium.currentContexts[exium.currentContexts.length - 1] ||
    getUnexpected(exium);
  return last;
}
function isEOF(exium) {
  const __char = getChar(exium);
  return Boolean(!__char || exium.source.length === exium.cursor.x);
}
function topCTX(exium, readers) {
  try {
    return Boolean(readers.find((reader) => reader(exium)));
  } catch (err) {
    throw err;
  }
}
class Exium1 {
  onError;
  treePosition = 0;
  allowPseudoProperties = true;
  isInPseudoProperty = false;
  currentContexts = [];
  openTags = [];
  cursor = {
    x: 0,
  };
  source = "";
  parseOptions = null;
  constructor(onError) {
    this.onError = onError;
  }
  scopedTopLevel = {
    lexer: [
      readCommentCtx,
      readCommentBlockCtx,
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readStringTemplateQuoteCtx,
    ],
    ogone: [
      readCommentCtx,
      readCommentBlockCtx,
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readStringSingleQuoteCtx,
      readStringDoubleQuoteCtx,
      readImportAmbientCtx,
      readImportStatementsCtx,
      readHTMLCommentCtx,
      readNodeCtx,
      readStyleSheetCtx,
      readProtocolCtx,
      readTextnodeCtx,
    ],
    bio: [
      readCommentCtx,
      readCommentBlockCtx,
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readStringSingleQuoteCtx,
      readStringDoubleQuoteCtx,
      readImportAmbientCtx,
      readImportStatementsCtx,
      readHTMLCommentCtx,
      readExportComponentStatementsCtx,
      readComponentCtx,
    ],
    script: [
      readCommentCtx,
      readCommentBlockCtx,
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readImportAmbientCtx,
      readImportStatementsCtx,
    ],
    stylesheet: [
      readCommentCtx,
      readCommentBlockCtx,
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readStyleSheetCtx,
    ],
    protocol: [
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readProtocolCtx,
    ],
    custom: [],
  };
  readSync(text, opts) {
    try {
      this.currentContexts.length && this.currentContexts.splice(0);
      this.parseOptions = opts;
      this.source = text;
      const toplevel = this.scopedTopLevel[opts.type];
      if (opts.type === "custom") {
        toplevel.push(...opts.contexts || []);
      }
      while (!isEOF(this)) {
        const isValid = topCTX(this, toplevel);
        if (!isValid) {
          this.onError(
            Reason1.UnexpectedToken,
            this.cursor,
            getUnexpected(this),
          );
          break;
        }
      }
      if (this.openTags.length) {
        const lastNode = this.openTags[this.openTags.length - 1];
        this.onError(Reason1.HTMLTagNotClosed, this.cursor, lastNode);
      }
      return this.currentContexts;
    } catch (err) {
      throw err;
    }
  }
  getPositionSync(context) {
    return context.getPosition(this.source);
  }
}
class ExiumDocument1 {
  url;
  injections;
  exium;
  contexts;
  text;
  idProvider = {};
  #_stylesheets;
  #_proto;
  #_head;
  #_protocol;
  #_template;
  #_components;
  #_type;
  constructor(opts) {
    this.exium = new Exium1(opts.onError);
    this.contexts = this.exium.readSync(
      opts.source,
      opts.options || {
        type: "ogone",
      },
    );
    this.url = opts.url;
    this.#_type = opts.options?.type || "ogone";
    this.injections = opts.injections;
    this.text = opts.source;
    this.#onload();
  }
  getText() {
    return this.text;
  }
  getPositionSync(context) {
    if (!this.contexts.includes(context)) {
      throw new Error("unexpected context, using the wrong document.");
    }
    return context.getPosition(this.text);
  }
  get styles() {
    if (this.#_type === "bio") {
      return [];
    }
    return this.#_stylesheets ||
      (this.#_stylesheets = this.contexts.filter((context) =>
        context.type === ContextTypes1.Node && context.name === "style"
      ));
  }
  get stylesheets() {
    if (this.#_type === "bio") {
      return [];
    }
    return this.#_stylesheets ||
      (this.#_stylesheets = this.contexts.filter((context) =>
        context.type === ContextTypes1.StyleSheet
      ));
  }
  get proto() {
    if (this.#_type === "bio") {
      return undefined;
    }
    return this.#_proto ||
      (this.#_proto = this.contexts.find((context) =>
        context.type === ContextTypes1.Node && context.related.find((related) =>
          related.source === "proto"
        ) && !context.data.parentNode && !context.data.isNodeClosing
      ));
  }
  get protocol() {
    if (this.#_type === "bio") {
      return undefined;
    }
    return this.#_protocol ||
      (this.#_protocol = this.contexts.find((context) =>
        context.type === ContextTypes1.Protocol
      ));
  }
  get template() {
    if (this.#_type === "bio") {
      return undefined;
    }
    return this.#_template ||
      (this.#_template = this.contexts.find((context) =>
        context.type === ContextTypes1.Node && context.related.find((related) =>
          related.source === "template"
        ) && context.data.parentNode &&
        !context.data.parentNode.data.parentNode && !context.data.isNodeClosing
      ));
  }
  get head() {
    if (this.#_type === "bio") {
      return undefined;
    }
    return this.#_head ||
      (this.#_head = this.contexts.find((context) =>
        context.type === ContextTypes1.Node && context.related.find((related) =>
          related.source === "head"
        ) && !context.data.isNodeClosing &&
        context.data.parentNode === this.template
      ));
  }
  get components() {
    if (this.#_type === "bio") {
      return this.contexts.filter((context) =>
        context.type === ContextTypes1.ComponentDeclaration
      );
    }
    return this.#_components ||
      (this.#_components = this.contexts.filter((context) =>
        context.type === ContextTypes1.Node && context.name &&
        context.name[0] === context.name[0].toUpperCase() &&
        !context.data.parentNode
      ));
  }
  getElementsByTagName(tagname) {
    return this.contexts.filter((context) => {
      return context.type === ContextTypes1.Node &&
        context.related.find((related) => related.source === tagname) &&
        !context.data.isNodeClosing;
    });
  }
  getElementsByClassName(className) {
    return this.contexts.filter((context) => {
      return context.type === ContextTypes1.Node &&
        context.children.find((child) => {
          const subChild = child.children[0];
          return child.type === ContextTypes1.Attribute &&
            child.related[0]?.source === "class" &&
            (subChild?.source === className ||
              typeof subChild.value === "string" &&
                subChild.value.split(" ").includes(className));
        }) && !context.data.isNodeClosing;
    });
  }
  getElementById(value) {
    return this.contexts.find((context) => {
      return context.type === ContextTypes1.Node &&
        context.children.find((child) =>
          child.type === ContextTypes1.Attribute &&
          child.related[0]?.source === "id" &&
          (child.children[0]?.source === value ||
            child.children[0]?.value === value)
        ) && !context.data.isNodeClosing;
    });
  }
  getElementsByFlag(flag) {
    return this.contexts.filter((context) => {
      return context.type === ContextTypes1.Node &&
        context.children.find((child) =>
          [
            ContextTypes1.Flag,
            ContextTypes1.FlagStruct,
          ].includes(child.type) && child.related.find((sub) =>
            sub.type === ContextTypes1.Identifier &&
            (sub.source === flag || sub.source.startsWith(`${flag}:`))
          )
        ) && !context.data.isNodeClosing;
    });
  }
  getFlagValue(element, flag) {
    if (!element || element.type !== ContextTypes1.Node) {
      throw new Error("first argument should be a Node");
    }
    const retrievedFlag = element.children.find((context) =>
      [
        ContextTypes1.Flag,
        ContextTypes1.FlagStruct,
      ].includes(context.type) && context.name === flag
    );
    if (!retrievedFlag) return undefined;
    const flagValue = retrievedFlag.children.find((context) =>
      [
        ContextTypes1.Braces,
        ContextTypes1.CurlyBrackets,
      ].includes(context.type)
    );
    if (!flagValue) return true;
    return flagValue.value;
  }
  getElementsByAttribute(attribute) {
    return this.contexts.filter((context) =>
      context.type === ContextTypes1.Node && context.children.find((child) =>
        child.type === ContextTypes1.Attribute &&
        child.related[0]?.source === attribute
      ) && !context.data.isNodeClosing
    );
  }
  getComponentByName(tagname) {
    return this.components.find((context) => context.name === tagname);
  }
  getExternalComponentByName(tagname) {
    const imports = this.getImportsOfExternalComponentByTagName(tagname);
    if (!imports.length) return null;
    return {
      elements: this.getElementsByTagName(tagname),
      imports,
    };
  }
  getImportsOfExternalComponentByTagName(tagname) {
    if (this.#_type === "bio") {
      return this.contexts.filter((context) => {
        const result = context.type === ContextTypes1.ImportStatement &&
          context.children.find((child) =>
            child.type === ContextTypes1.IdentifierList &&
            child.children.find((subchild) => subchild.source === tagname)
          ) && context.data.isComponent;
        return result;
      });
    }
    return this.contexts.filter((context) =>
      context.type === ContextTypes1.ImportStatement &&
      context.source.includes(tagname) && context.data.isComponent
    );
  }
  getIdentifiersOfExternalComponents() {
    const accumulated = [];
    this.contexts.forEach((context) => {
      if (
        context.type !== ContextTypes1.ImportStatement ||
        !context.data.isComponent
      ) {
        return;
      }
      const identifierList = context.children.find((child) =>
        child.type === ContextTypes1.IdentifierList
      );
      const identifier = context.children.find((child) =>
        child.type === ContextTypes1.Identifier
      );
      if (identifierList) {
        accumulated.push(
          ...identifierList.children.filter((context1) =>
            context1.type === ContextTypes1.Identifier
          ),
        );
      }
      if (identifier) {
        accumulated.push(identifier);
      }
    });
    return accumulated;
  }
  getExportedComponents() {
    const accumulated = [];
    this.contexts.forEach((context) => {
      if (context.type !== ContextTypes1.ExportStatement) return;
      const componentDeclaration = context.children.find((child) =>
        child.type === ContextTypes1.ComponentDeclaration &&
        child.data.isExported
      );
      if (componentDeclaration) {
        accumulated.push(componentDeclaration);
      }
    });
    return accumulated;
  }
  getLocalComponents() {
    const accumulated = [];
    this.contexts.forEach((context) => {
      if (
        context.type !== ContextTypes1.ComponentDeclaration ||
        context.data.isExported
      ) {
        return;
      }
      accumulated.push(context);
    });
    return accumulated;
  }
  getURLFromImport(importStatement) {
    if (
      !importStatement || ![
        ContextTypes1.ImportAmbient,
        ContextTypes1.ImportStatement,
      ].includes(importStatement.type)
    ) {
      throw new Error(
        "Unexpected in getURLFromImport: first argument should be an import context",
      );
    }
    const path = importStatement.data.path;
    if (!path) {
      throw new Error("path field is not exposed from the ImportStatement");
    }
    return new URL(path.source.replace(/(^['"]|['"]$)/gi, ""), this.url);
  }
  getType() {
    switch (this.#_type) {
      case "bio":
        return "bio";
      case "stylesheet":
        return "stylesheet";
      case "protocol":
        return "protocol";
      case "ogone": {
        const [component] = this.components;
        const { proto } = component;
        if (!proto) return "component";
        const type1 = proto.getAttribute("type");
        return type1 && type1.length ? type1 : "component";
      }
    }
    return "component";
  }
  getStylesheetRulesByTagName(tagname) {
    if (this.#_type !== "stylesheet") return [];
    return this.contexts.filter((child) => {
      return child.type === ContextTypes1.StyleSheetSelectorList &&
        child.children.find((subchild) =>
          subchild.type === ContextTypes1.StyleSheetSelectorHTMLElement &&
          subchild.source === tagname
        );
    });
  }
  getStylesheetRulesByClassName(className) {
    if (this.#_type !== "stylesheet") return [];
    return this.contexts.filter((child) => {
      return child.type === ContextTypes1.StyleSheetSelectorList &&
        child.children.find((subchild) =>
          subchild.type === ContextTypes1.StyleSheetSelectorClass &&
          subchild.source === `.${className}`
        );
    });
  }
  getStylesheetRulesById(id) {
    if (this.#_type !== "stylesheet") return [];
    return this.contexts.filter((child) => {
      return child.type === ContextTypes1.StyleSheetSelectorList &&
        child.children.find((subchild) =>
          subchild.type === ContextTypes1.StyleSheetSelectorId &&
          subchild.source === `#${id}`
        );
    });
  }
  getStylesheetRulesByAttribute(attr) {
    if (this.#_type !== "stylesheet") return [];
    return this.contexts.filter((child) => {
      return child.type === ContextTypes1.StyleSheetSelectorList &&
        child.children.find((subchild) =>
          subchild.type === ContextTypes1.StyleSheetSelectorAttribute &&
          subchild.name === attr
        );
    });
  }
  getStylesheetRulesByProperty(property, value) {
    if (this.#_type !== "stylesheet") return [];
    return this.contexts.filter((child) => {
      return child.type === ContextTypes1.StyleSheetSelectorList &&
        child.related.find((subchild) =>
          subchild.type === ContextTypes1.StyleSheetPropertyList &&
          subchild.children.find((props) =>
            !value && props.type === ContextTypes1.StyleSheetProperty &&
              props.name === property ||
            value && props.type === ContextTypes1.StyleSheetProperty &&
              props.name === property && props.related.find((propValue) =>
                propValue.type === ContextTypes1.StyleSheetPropertyValue &&
                propValue.source.trim() === value
              )
          )
        );
    });
  }
  getStylesheetRulesByPseudoProperty(property) {
    if (this.#_type !== "stylesheet") return [];
    return this.contexts.filter((child) => {
      return child.type === ContextTypes1.StyleSheetSelectorList &&
        child.related.find((subchild) =>
          subchild.type === ContextTypes1.StyleSheetPropertyList &&
          subchild.children.find((props) => {
            return props.type === ContextTypes1.StyleSheetPseudoProperty &&
              props.name === property;
          })
        );
    });
  }
  getStylesheetConstants() {
    if (this.#_type !== "stylesheet") return [];
    return this.contexts.filter((context) => {
      return context.type === ContextTypes1.StyleSheetAtRuleConst;
    });
  }
  getStylesheetExportedConstants() {
    if (this.#_type !== "stylesheet") return [];
    const exports = this.contexts.filter((context) => {
      return context.type === ContextTypes1.StyleSheetAtRuleExport;
    });
    const isConst = exports.filter((exp) =>
      exp.children.find((child) =>
        child.type === ContextTypes1.StyleSheetAtRuleConst
      )
    );
    return isConst.map((exp) =>
      exp.children.find((child) =>
        child.type === ContextTypes1.StyleSheetAtRuleConst
      )
    );
  }
  getStylesheetConstant(name) {
    if (this.#_type !== "stylesheet") return undefined;
    return this.contexts.find((context) => {
      return context.type === ContextTypes1.StyleSheetAtRuleConst &&
        context.name === name;
    });
  }
  getStylesheetExportedConstant(name) {
    if (this.#_type !== "stylesheet") return undefined;
    const exportCTX = this.contexts.find((context) => {
      return context.type === ContextTypes1.StyleSheetAtRuleExport;
    });
    if (!exportCTX) return undefined;
    return exportCTX.children.find((child) =>
      child.type === ContextTypes1.StyleSheetAtRuleConst && child.name === name
    );
  }
  prepareTheIdProvider() {
    Object.assign(this.idProvider, {
      node: 0,
      textnode: 0,
      styleRule: 0,
    });
  }
  #onload() {
    this.prepareTheIdProvider();
    this.contexts.forEach((context) => {
      switch (context.type) {
        case ContextTypes1.Node:
          context.parentNode?.children.push(context);
          context.id = this.idProvider.node;
          this.idProvider.node++;
          break;
        case ContextTypes1.TextNode:
          context.id = this.idProvider.textnode;
          this.idProvider.textnode++;
          break;
        case ContextTypes1.StyleSheetRule:
          context.id = this.idProvider.stylerule;
          this.idProvider.stylerule++;
          break;
      }
      context.document = this;
    });
  }
}
export {
  ContextTypes1 as ContextTypes,
  ExiumContext1 as ExiumContext,
  ExiumDocument1 as ExiumDocument,
  Reason1 as Reason,
};
export { Exium1 as Exium };
function readCommentBlockCtx(exium, opts1) {
  try {
    const __char = getChar(exium);
    const next = getNext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    if (__char !== "/" || __char === "/" && next !== "*") return false;
    if (opts1?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    const allSubContexts = [
      readLineBreakCtx,
    ];
    const children = [];
    while (!isEOF(exium)) {
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
      saveContextsTo(exium, allSubContexts, children);
      if (getChar(exium) === "/" && getPrev(exium) === "*") {
        shift(exium, 1);
        isClosed = true;
        break;
      }
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.CommentBlock, token, x);
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.CommentBlockOpen, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readCommentCtx(exium, opts1) {
  try {
    const __char = getChar(exium);
    const next = getNext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    if (__char !== "/" || __char === "/" && next !== "/") return false;
    if (opts1?.checkOnly) return true;
    const result = true;
    while (!isEOF(exium)) {
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
      if (getChar(exium) === "\n") {
        exium.cursor.x++;
        break;
      }
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.Comment, token, x);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStringSingleQuoteCtx(exium, opts1) {
  try {
    const __char = getChar(exium);
    const prev = getPrev(exium);
    const { source: source2 } = exium;
    const { x } = exium.cursor;
    if (__char !== "'" || __char === "'" && prev === "\\") return false;
    if (opts1?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    while (!isEOF(exium)) {
      shift(exium, 1);
      isValidChar(
        exium,
        opts1?.unexpected || [
          readLineBreakCtx,
        ],
      );
      if (getChar(exium) === "'" && getPrev(exium) !== "\\") {
        shift(exium, 1);
        isClosed = true;
        break;
      }
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StringSingleQuote,
      token,
      x,
    );
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.StringSingleQuoteOpen, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readStringDoubleQuoteCtx(exium, opts1) {
  try {
    const __char = getChar(exium);
    const prev = getPrev(exium);
    const { source: source2 } = exium;
    const { x } = exium.cursor;
    if (__char !== '"' || __char === '"' && prev === "\\") return false;
    if (opts1?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    while (!isEOF(exium)) {
      shift(exium, 1);
      isValidChar(
        exium,
        opts1?.unexpected || [
          readLineBreakCtx,
        ],
      );
      if (getChar(exium) === '"' && getPrev(exium) !== "\\") {
        shift(exium, 1);
        isClosed = true;
        break;
      }
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StringDoubleQuote,
      token,
      x,
    );
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.StringDoubleQuoteOpen, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readStringTemplateQuoteCtx(exium, opts1) {
  try {
    const __char = getChar(exium);
    const prev = getPrev(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    if (__char !== "`" || __char === "`" && prev === "\\") return false;
    if (opts1?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    const allSubContexts = [
      readLineBreakCtx,
      readStringTemplateQuoteEvalCtx,
    ];
    const children = [];
    while (!isEOF(exium)) {
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
      saveContextsTo(exium, allSubContexts, children);
      if (getChar(exium) === "`" && getPrev(exium) !== "\\") {
        shift(exium, 1);
        isClosed = true;
        break;
      }
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StringTemplateQuote,
      token,
      x,
    );
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.StringTemplateQuoteOpen, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readStringTemplateQuoteEvalCtx(exium, opts1) {
  try {
    const __char = getChar(exium);
    const prev = getPrev(exium);
    const next = getNext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    if (
      __char !== "$" || __char === "$" && prev === "\\" ||
      __char === "$" && next !== "{"
    ) {
      return false;
    }
    if (opts1?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    const allSubContexts = [
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readStringTemplateQuoteCtx,
    ];
    const children = [];
    while (!isEOF(exium)) {
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
      saveContextsTo(exium, allSubContexts, children);
      if (getChar(exium) === "}" && getPrev(exium) !== "\\") {
        shift(exium, 1);
        isClosed = true;
        break;
      }
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StringTemplateQuoteEval,
      token,
      x,
    );
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(
        Reason1.StringTemplateQuoteEvaluationOpen,
        exium.cursor,
        context,
      );
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readMultiSpacesCtx(exium, opts1) {
  debuggPosition(exium, "\n\n\t\tMULTISPACE START");
  try {
    const __char = getChar(exium);
    const next = getNext(exium);
    const { source: source2 } = exium;
    if (__char !== " " || next !== " ") return false;
    const { x } = exium.cursor;
    let result = false;
    while (getChar(exium) === " ") {
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
    }
    result = x !== exium.cursor.x;
    if (result) {
      const token = source2.slice(x, exium.cursor.x);
      exium.currentContexts.push(
        new ExiumContext1(ContextTypes1.MultipleSpaces, token, x),
      );
    }
    debuggPosition(exium, "\n\n\t\tMULTISPACE END");
    return result;
  } catch (err) {
    throw err;
  }
}
function readIdentifierAsterixCtx(exium, opts1) {
  debuggPosition(exium, "ASTERIX CTX START");
  const { x } = exium.cursor;
  const __char = getChar(exium);
  const { source: source2 } = exium;
  const isValid = __char === "*";
  if (!isValid) return false;
  if (opts1?.checkOnly) return true;
  shift(exium, 1);
  const related = [];
  saveStrictContextsTo(exium, [
    readMultiSpacesCtx,
    readSpaceCtx,
    readIdentifierAliasCtx,
  ], related);
  const isGlobalAlias = related.find((context) =>
    context.type === ContextTypes1.IdentifierAsStatement
  );
  const token = source2.slice(x, exium.cursor.x);
  const context = new ExiumContext1(
    isGlobalAlias ? ContextTypes1.ImportAllAlias : ContextTypes1.Asterix,
    token,
    x,
  );
  exium.currentContexts.push(context);
  debuggPosition(exium, "ASTERIX CTX END");
  return true;
}
function readIdentifierCtx(exium, opts1) {
  debuggPosition(exium, "Identifier CTX START");
  const { x } = exium.cursor;
  if (
    !isCharIdentifier(exium) && !opts1?.data?.allowDigit && !isCharDigit(exium)
  ) {
    return false;
  }
  if (opts1?.checkOnly) return true;
  const allowAliases = opts1?.data?.identifier_allow_alias;
  const allowedIdentifierChars = [
    ...opts1?.data?.allowedIdentifierChars || [],
  ];
  shift(exium, 1);
  let isAliased = false;
  const related = [];
  while (!isEOF(exium)) {
    const nextPart = getNextPart(exium);
    if (!isAliased && allowAliases && asRegExp.test(nextPart)) {
      saveContextsTo(exium, [
        readMultiSpacesCtx,
        readSpaceCtx,
        readIdentifierAliasCtx,
      ], related);
      const recognized = related.find((context) =>
        context.type === ContextTypes1.IdentifierAsStatement
      );
      if (recognized) {
        related.push(recognized);
        isAliased = true;
      }
    }
    if (
      (isCharPuntuation(exium) || isCharSpacing(exium)) &&
      !allowedIdentifierChars.includes(getChar(exium))
    ) {
      break;
    }
    shift(exium, 1);
  }
  const token = exium.source.slice(x, exium.cursor.x);
  const context = new ExiumContext1(ContextTypes1.Identifier, token, x);
  exium.currentContexts.push(context);
  context.related.push(...related);
  return true;
}
function readIdentifierListCtx(exium, opts1) {
  debuggPosition(exium, "Identifier LIST CTX Start");
  const __char = getChar(exium);
  const { source: source2 } = exium;
  const isValid = __char === "{";
  if (!isValid) return false;
  if (opts1?.checkOnly) return true;
  const { x } = exium.cursor;
  shift(exium, 1);
  const readers = [
    readLineBreakCtx,
    readSpaceCtx,
    readMultiSpacesCtx,
  ];
  const children = [];
  let isComaNeeded = false;
  let isUnexpected = false;
  while (!isEOF(exium)) {
    saveContextsTo(exium, readers, children);
    if (
      !isComaNeeded && readIdentifierCtx(exium, checkOnlyOptions) &&
      getChar(exium) !== ","
    ) {
      const identified = readIdentifierCtx(exium, opts1);
      if (identified) {
        const lastContext = getLastContext(exium);
        children.push(lastContext);
        isComaNeeded = true;
      }
    }
    if (isComaNeeded && getChar(exium) === ",") {
      const identifiedComa = readComaCtx(exium);
      if (identifiedComa) {
        const lastContext = getLastContext(exium);
        children.push(lastContext);
        isComaNeeded = false;
      }
    }
    if (!(getChar(exium) === "}" || isCharSpacing(exium))) {
      isUnexpected = true;
    }
    if (isUnexpected) {
      exium.onError(
        Reason1.UnexpectedToken,
        exium.cursor,
        getUnexpected(exium),
      );
    }
    if (getChar(exium) === "}") {
      shift(exium, 1);
      break;
    }
    isValidChar(exium, opts1?.unexpected);
    shift(exium, 1);
  }
  const token = source2.slice(x, exium.cursor.x);
  const context = new ExiumContext1(ContextTypes1.IdentifierList, token, x);
  exium.currentContexts.push(context);
  context.children.push(...children);
  return true;
}
function readIdentifierAliasCtx(exium, opts1) {
  const { x } = exium.cursor;
  const { source: source2 } = exium;
  const identified = readIdentifierCtx(exium);
  const children = [];
  let isValid = false;
  if (identified) {
    const lastContext = getLastContext(exium);
    isValid = lastContext.source === "as";
    if (isValid) lastContext.type = ContextTypes1.AsStatement;
  }
  if (!isValid) return false;
  if (opts1?.checkOnly) return true;
  let isIdentified = false;
  const allsubs = [
    readMultiSpacesCtx,
    readSpaceCtx,
    readIdentifierCtx,
  ];
  while (!isEOF(exium)) {
    saveStrictContextsTo(exium, allsubs, children);
    isIdentified = !!children.find((context) =>
      context.type === ContextTypes1.Identifier
    );
    if (isIdentified) {
      break;
    }
    shift(exium, 1);
  }
  const token = source2.slice(x, exium.cursor.x);
  const context = new ExiumContext1(
    ContextTypes1.IdentifierAsStatement,
    token,
    x,
  );
  exium.currentContexts.push(context);
  context.children.push(...children);
  if (!isIdentified) {
    exium.onError(Reason1.AsStatementMissingIdentifier, exium.cursor, context);
  }
  return true;
}
function readSpaceCtx(exium) {
  debuggPosition(exium, "\n\n\t\tSPACE START");
  const result = getChar(exium) === " " && getNext(exium) !== getChar(exium);
  if (result) {
    exium.currentContexts.push(
      new ExiumContext1(ContextTypes1.Space, getChar(exium), exium.cursor.x),
    );
    shift(exium, 1);
  }
  debuggPosition(exium, "\n\n\t\tSPACE START");
  return result;
}
function readSemiColonCtx(exium) {
  debuggPosition(exium, "\n\n\t\tSEMICOLON START");
  const result = getChar(exium) === ";";
  if (result) {
    exium.currentContexts.push(
      new ExiumContext1(
        ContextTypes1.SemiColon,
        getChar(exium),
        exium.cursor.x,
      ),
    );
    shift(exium, 1);
  }
  debuggPosition(exium, "\n\n\t\tSEMICOLON END");
  return result;
}
function readComaCtx(exium) {
  debuggPosition(exium, "\n\n\t\tCOMA START");
  const result = getChar(exium) === ",";
  if (result) {
    exium.currentContexts.push(
      new ExiumContext1(ContextTypes1.Coma, getChar(exium), exium.cursor.x),
    );
    shift(exium, 1);
  }
  debuggPosition(exium, "\n\n\t\tCOMA END");
  return result;
}
function readDoublePointCtx(exium) {
  debuggPosition(exium, "\n\n\t\tDOUBLE POINT START");
  const result = getChar(exium) === ":";
  if (result) {
    exium.currentContexts.push(
      new ExiumContext1(
        ContextTypes1.DoublePoint,
        getChar(exium),
        exium.cursor.x,
      ),
    );
    shift(exium, 1);
  }
  debuggPosition(exium, "\n\n\t\tDOUBLE POINT END");
  return result;
}
function readLineBreakCtx(exium) {
  debuggPosition(exium, "\n\n\t\tLINEBREAK START");
  const { x } = exium.cursor;
  const isChariot = getChar(exium) === "\r" && getNext(exium) === "\n";
  const result = getChar(exium) === "\n" || isChariot;
  if (result) {
    if (isChariot) shift(exium, 2);
    else shift(exium, 1);
    exium.currentContexts.push(
      new ExiumContext1(ContextTypes1.LineBreak, getChar(exium), x),
    );
  }
  debuggPosition(exium, "\n\n\t\tLINEBREAK END");
  return result;
}
function readBracesCtx(exium, opts1) {
  try {
    debuggPosition(exium, "readBracesCtx START");
    const __char = getChar(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    if (__char !== "(") return false;
    if (opts1?.checkOnly) return true;
    shift(exium, 1);
    const result = true;
    let isClosed = false;
    const allSubContexts = [
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readBracesCtx,
      ...opts1?.data?.braces_contexts || [],
    ];
    const children = [];
    while (!isEOF(exium)) {
      debuggPosition(exium, "readBracesCtx");
      isValidChar(exium, opts1?.unexpected);
      saveContextsTo(exium, allSubContexts, children);
      if (getChar(exium) === ")") {
        shift(exium, 1);
        isClosed = true;
        break;
      }
      shift(exium, 1);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.Braces, token, x);
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.BracesOpen, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readCurlyBracketsCtx(exium, opts1) {
  try {
    const __char = getChar(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    if (__char !== "{") return false;
    if (opts1?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    const allSubContexts = opts1?.contexts || [
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readCurlyBracketsCtx,
    ];
    const children = [];
    while (!isEOF(exium)) {
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
      saveContextsTo(exium, allSubContexts, children);
      if (getChar(exium) === "}") {
        shift(exium, 1);
        isClosed = true;
        break;
      }
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.CurlyBrackets, token, x);
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.CurlyBracketsOpen, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readArrayCtx(exium, opts1) {
  try {
    const __char = getChar(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    if (__char !== "[") return false;
    if (opts1?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    const allSubContexts = [
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readArrayCtx,
    ];
    const children = [];
    shift(exium, 1);
    while (!isEOF(exium)) {
      saveContextsTo(exium, allSubContexts, children);
      if (getChar(exium) === "]") {
        shift(exium, 1);
        isClosed = true;
        break;
      }
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.Array, token, x);
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.ArrayOpen, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readParentheseCtx(exium, opts1) {
  try {
    const __char = getChar(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    if (__char !== "(") return false;
    if (opts1?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    const allSubContexts = opts1?.contexts || [
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readArrayCtx,
      readParentheseCtx,
    ];
    const children = [];
    while (!isEOF(exium)) {
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
      saveContextsTo(exium, allSubContexts, children);
      if (getChar(exium) === ")") {
        shift(exium, 1);
        isClosed = true;
        break;
      }
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.Parenthese, token, x);
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.ParentheseOpen, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readArgumentCtx(exium, opts1) {
  try {
    const __char = getChar(exium);
    const { source: source2 } = exium;
    const { x } = exium.cursor;
    const startingChar = opts1 && opts1.data?.readArgumentCtx_starts_with ||
      ":";
    const isValid = __char === startingChar;
    if (!isValid) return false;
    shiftUntilEndOf(exium, startingChar);
    const related = [];
    const children = [];
    while (!isEOF(exium)) {
      isValidChar(exium, opts1 && opts1?.unexpected);
      Boolean(
        readIdentifierCtx(exium, {
          data: {
            allowedIdentifierChars: [
              "-",
            ],
          },
        }) && related.push(getLastContext(exium)),
      );
      if (isCharPuntuation(exium)) break;
      shift(exium, 1);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.Argument, token, x);
    context.related.push(...related);
    context.children.push(...children);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readImportStatementsCtx(exium, opts1) {
  try {
    const nextPart = getNextPart(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = importRegExp.test(nextPart);
    const isComponent = importComponentRegExp.test(nextPart);
    if (!isValid) {
      return false;
    }
    if (opts1?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    let fromStatement = null;
    const related = [];
    const children = [];
    shiftUntilEndOf(exium, "import");
    if (isComponent) {
      saveStrictContextsTo(exium, [
        readMultiSpacesCtx,
        readSpaceCtx,
      ], children);
      saveToken(exium, "component", ContextTypes1.ImportComponentStatement);
    }
    while (!isEOF(exium)) {
      saveStrictContextsTo(
        exium,
        [
          readMultiSpacesCtx,
          readSpaceCtx,
          readIdentifierAsterixCtx,
          readIdentifierListCtx,
          readIdentifierCtx,
          readMultiSpacesCtx,
          readComaCtx,
          readSpaceCtx,
        ],
        children,
        isComponent ? undefined : {
          data: {
            identifier_allow_alias: true,
          },
        },
      );
      fromStatement = saveToken(
        exium,
        "from",
        ContextTypes1.ImportStatementFrom,
      );
      if (fromStatement) {
        break;
      }
      isValidChar(exium, opts1?.unexpected);
    }
    const nextContexts = [
      readMultiSpacesCtx,
      readSpaceCtx,
      readStringDoubleQuoteCtx,
      readStringSingleQuoteCtx,
      readSemiColonCtx,
    ];
    nextContexts.forEach((reader, i, arr) => {
      const recognized = reader(exium);
      if (recognized) {
        related.push(getLastContext(exium));
        delete arr[i];
      }
    });
    const str = related.find((context) =>
      [
        ContextTypes1.StringSingleQuote,
        ContextTypes1.StringDoubleQuote,
      ].includes(context.type)
    );
    isClosed = Boolean(
      fromStatement && str && related.find((context) =>
        [
          ContextTypes1.SemiColon,
        ].includes(context.type)
      ),
    );
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.ImportStatement, token, x);
    Object.assign(context.data, {
      isComponent,
      path: str,
    });
    if (fromStatement) {
      context.related.push(fromStatement);
    }
    context.related.push(...related);
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.ImportStatementNotFinish, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readImportAmbientCtx(exium, opts1) {
  try {
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    if (!/^import\s*(["'])(.*?)(\1)/i.test(getNextPart(exium))) return false;
    if (opts1?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    const related = [];
    const nextContexts = [
      readMultiSpacesCtx,
      readSpaceCtx,
      readStringDoubleQuoteCtx,
      readStringSingleQuoteCtx,
      readSemiColonCtx,
    ];
    while (!isEOF(exium)) {
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
      if (
        getChar(exium) === " " || [
          '"',
          "'",
        ].includes(getChar(exium))
      ) {
        break;
      }
    }
    nextContexts.forEach((reader, i, arr) => {
      const recognized = reader(exium);
      if (recognized) {
        related.push(getLastContext(exium));
        delete arr[i];
      }
    });
    const str = related.find((context) =>
      [
        ContextTypes1.StringDoubleQuote,
        ContextTypes1.StringSingleQuote,
      ].includes(context.type)
    );
    isClosed = Boolean(
      str && related.find((context) =>
        [
          ContextTypes1.SemiColon,
        ].includes(context.type)
      ),
    );
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.ImportAmbient, token, x);
    Object.assign(context.data, {
      path: str,
    });
    context.related.push(...related);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.ImportAmbientStringMissing, exium.cursor, context);
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readProtocolCtx(exium, opts1) {
  try {
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const lastIsAStyleNode = exium.currentContexts.find((context) =>
      context.type === ContextTypes1.Node && context.related.find((node) =>
        node.type === ContextTypes1.Identifier && node.source === "proto"
      ) && !context.related.find((node) =>
        node.type === ContextTypes1.NodeClosing
      )
    );
    const isValid = !!lastIsAStyleNode;
    if (!isValid) return false;
    if (opts1?.checkOnly) return true;
    const result = true;
    const children = [];
    const allSubContexts = [
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
    ];
    while (!isEOF(exium)) {
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
      saveContextsTo(exium, allSubContexts, children);
      if (isStartingNode(exium) && getNextPart(exium).startsWith("</proto")) {
        break;
      }
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.Protocol, token, x);
    context.children.push(...children);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function isEndOfStylesheetProperty(exium) {
  const __char = getChar(exium);
  const { isInPseudoProperty: p } = exium;
  return p && __char === ")" || !p && __char === "}";
}
function readStyleSheetCtx(exium, opts1) {
  debuggPosition(exium, "STYLESHEET START  ==================>");
  try {
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const lastIsAStyleNode = exium.currentContexts.find((context) =>
      context.type === ContextTypes1.Node && context.related.find((node) =>
        node.type === ContextTypes1.Identifier && node.source === "style"
      ) && !context.related.find((node) =>
        node.type === ContextTypes1.NodeClosing
      )
    );
    const isValid = !!lastIsAStyleNode || isParsingStylesheet(exium);
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return !isEndOfStylesheet(exium);
    const result = true;
    const children = [];
    const allSubContexts = [
      readStylesheetEndCtx,
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readCommentBlockCtx,
      readCommentCtx,
      readSemiColonCtx,
      readStyleSheetCharsetAtRuleCtx,
      readStyleSheetConstAtRuleCtx,
      readStyleSheetExportAtRuleCtx,
      readStyleSheetDefaultAtRuleCtx,
      readStyleSheetPropertyListCtx,
      readStyleSheetSelectorListCtx,
      readStyleSheetPropertyListCtx,
    ];
    saveContextsTo(exium, allSubContexts, children);
    while (!isEOF(exium)) {
      saveStrictContextsTo(exium, allSubContexts, children);
      isValidChar(exium, opts1?.unexpected);
      if (isEndOfStylesheet(exium)) {
        break;
      }
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.StyleSheet, token, x);
    context.children.push(...children);
    exium.currentContexts.push(context);
    debuggPosition(exium, "STYLESHEET END");
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetCharsetAtRuleCtx(exium, opts1) {
  debuggPosition(exium, "readStyleSheetCharsetAtRuleCtx");
  try {
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = Boolean(isFollowedBy(exium, "@charset", true));
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    const children = [];
    const allSubContexts = [
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readStringDoubleQuoteCtx,
      readStringSingleQuoteCtx,
      readSemiColonCtx,
    ];
    while (!isEOF(exium)) {
      saveContextsTo(exium, allSubContexts, children);
      if (
        children.find((context) => context.type === ContextTypes1.SemiColon)
      ) {
        break;
      }
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
    }
    isClosed = Boolean(
      children.length && children.find((context) =>
        [
          ContextTypes1.StringSingleQuote,
          ContextTypes1.StringDoubleQuote,
        ].includes(context.type)
      ),
    );
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetAtRuleCharset,
      token,
      x,
    );
    context.children.push(...children);
    exium.currentContexts.push(context);
    const str = children.find((context1) =>
      [
        ContextTypes1.StringSingleQuote,
        ContextTypes1.StringDoubleQuote,
      ].includes(context1.type)
    );
    if (str) {
      let isValidCharset = false;
      const strCharset = str.source.slice(1, -1);
      SupportedStyleSheetCharset.forEach((charset) => {
        if (charset.toLowerCase() === strCharset || charset === strCharset) {
          isValidCharset = true;
        }
      });
      if (!isValidCharset) {
        exium.onError(
          Reason1.StyleSheetAtRuleCharsetInvalid,
          exium.cursor,
          context,
        );
      }
    } else {
      exium.onError(
        Reason1.StyleSheetAtRuleCharsetStringIsMissing,
        exium.cursor,
        context,
      );
    }
    if (!isClosed) {
      exium.onError(
        Reason1.StyleSheetAtRuleCharsetNotFinish,
        exium.cursor,
        context,
      );
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetExportAtRuleCtx(exium, opts1) {
  try {
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = Boolean(isFollowedBy(exium, "@export", true));
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    const result = true;
    const children = [];
    const allSubContexts = [
      readMultiSpacesCtx,
      readSpaceCtx,
      readStyleSheetConstAtRuleCtx,
      readStylesheetEndCtx,
    ];
    while (!isEOF(exium)) {
      saveStrictContextsTo(exium, allSubContexts, children, {
        data: {
          isExportStatement: true,
        },
      });
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
      if (getChar(exium) === ";" || getPrev(exium) === ";") {
        break;
      }
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetAtRuleExport,
      token,
      x,
    );
    context.children.push(...children);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetConstAtRuleCtx(exium, opts1) {
  debuggPosition(exium, "readStyleSheetConstAtRuleCtx");
  try {
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = Boolean(
      isFollowedBy(exium, "@const", true) || opts1?.data?.isExportStatement,
    );
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    getNextPart(exium).startsWith("const ") && shiftUntilEndOf(exium, "const");
    const result = true;
    let isNamed = false;
    const children = [];
    const related = [];
    const allSubContexts = [
      readMultiSpacesCtx,
      readSpaceCtx,
      readSemiColonCtx,
      readLineBreakCtx,
      readStylesheetEndCtx,
    ];
    const describers = [
      readStylesheetEndCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readIdentifierCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readStyleSheetTypeAssignementCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readStyleSheetConstAtRuleEqualCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readStyleSheetHexTypeCtx,
      readStyleSheetSelectorListCtx,
      readStyleSheetPropertyListCtx,
    ];
    while (!isEOF(exium)) {
      if (!isNamed) {
        saveContextsTo(exium, describers, related, {
          data: {
            force_type_assignment_context: true,
            force_property_list_context: true,
          },
        });
        isNamed = Boolean(
          related.find((context) =>
            context.type === ContextTypes1.Identifier
          ) && related.find((context) =>
            context.type === ContextTypes1.StyleSheetAtRuleConstEqual
          ) && related.find((context) =>
            context.type === ContextTypes1.StyleSheetTypeAssignment
          ),
        );
      } else {
        saveContextsTo(exium, allSubContexts, children);
      }
      if (getChar(exium) === ";") {
        break;
      }
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetAtRuleConst,
      token,
      x,
    );
    context.children.push(...children);
    context.related.push(...related);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetHexTypeCtx(exium, opts1) {
  debuggPosition(exium, "STYLESHEET HEX TYPE START");
  const __char = getChar(exium);
  const { source: source2 } = exium;
  const { x } = exium.cursor;
  if (__char !== "#") return false;
  if (opts1?.checkOnly) return true;
  while (!isEOF(exium)) {
    debuggPosition(exium, "STYLESHEET HEX TYPE");
    if (
      [
        " ",
        ";",
        "\n",
      ].includes(getChar(exium)) || exium.cursor.x - x >= 8
    ) {
      break;
    }
    shift(exium, 1);
  }
  const token = source2.slice(x, exium.cursor.x);
  const context = new ExiumContext1(ContextTypes1.StyleSheetHexType, token, x);
  exium.currentContexts.push(context);
  return true;
}
function readStyleSheetConstAtRuleEqualCtx(exium, opts1) {
  debuggPosition(exium, "STYLESHEET CONST AT RULE EQUAL START");
  try {
    const __char = getChar(exium);
    const next = getNext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = __char === "=" && next !== "=";
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    debuggPosition(exium, "STYLESHEET CONST AT RULE EQUAL");
    shift(exium, 1);
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetAtRuleConstEqual,
      token,
      x,
    );
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetDefaultAtRuleCtx(exium, opts1) {
  debuggPosition(exium, "\nDEFAULT AT RULE");
  try {
    const __char = getChar(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = Boolean(__char === "@");
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    shift(exium, 1);
    const result = true;
    let isTyped = false;
    const children = [];
    const describers = [
      readStyleSheetTypeAssignementCtx,
      readIdentifierCtx,
    ];
    const allSubContexts = [
      readMultiSpacesCtx,
      readSpaceCtx,
      readLineBreakCtx,
      readStyleSheetSelectorListCtx,
    ];
    const related = [];
    saveContextsTo(exium, describers, related);
    isTyped = !!related.find((context) =>
      context.type === ContextTypes1.StyleSheetTypeAssignment
    );
    while (!isEOF(exium)) {
      saveContextsTo(exium, allSubContexts, children);
      if (
        getChar(exium) === "{" || getChar(exium) === ";" ||
        isEndOfStylesheet(exium)
      ) {
        break;
      }
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.StyleSheetAtRule, token, x);
    context.children.push(...children);
    context.related.push(...related);
    context.data.isTyped = isTyped;
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetTypeAssignementCtx(exium, opts1) {
  debuggPosition(exium, "\nCONST TYPE");
  try {
    const __char = getChar(exium);
    const prev = getPrev(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = Boolean(
      prev === "@" && __char === "<" ||
        opts1?.data?.force_type_assignment_context,
    );
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    const children = [];
    const allSubContexts = opts1?.contexts || [];
    while (!isEOF(exium)) {
      saveContextsTo(exium, allSubContexts, children);
      if (getChar(exium) === ">") {
        shift(exium, 1);
        isClosed = true;
        break;
      }
      shift(exium, 1);
      isValidChar(
        exium,
        opts1?.unexpected || [
          readStyleSheetTypeAssignementCtx,
          readStyleSheetDefaultAtRuleCtx,
        ],
      );
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetTypeAssignment,
      token,
      x,
    );
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(
        Reason1.StyleSheetTypeAssignmentNotFinish,
        exium.cursor,
        context,
      );
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetSelectorListCtx(exium, opts1) {
  debuggPosition(exium, "SELECTOR LIST");
  try {
    const __char = getChar(exium);
    const nextPart = getNextPart(exium);
    const next = getNext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = ![
      ",",
      "@",
      " ",
      "\n",
      "}",
      "{",
    ].includes(__char) && /^([^;\{\}]*?)(\{)/gi.test(nextPart);
    if (!isValid || __char === next && __char === ".") {
      return false;
    }
    if (opts1?.checkOnly) return true;
    const result = true;
    const supportedSelectors = [
      readStylesheetEndCtx,
      readSelectorCombinatorCtx,
      readStyleSheetSelectorAttributeCtx,
      readStyleSheetSelectorPseudoElementCtx,
      readStyleSheetSelectorPseudoClassCtx,
      readStyleSheetSelectorIdCtx,
      readStyleSheetSelectorClassCtx,
      readStyleSheetParentRefCtx,
      readStyleSheetSelectorElementCtx,
    ];
    const comaCTX = [
      readMultiSpacesCtx,
      readSpaceCtx,
      readLineBreakCtx,
      readComaCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readLineBreakCtx,
    ];
    const allSubContexts = opts1?.contexts || [
      readMultiSpacesCtx,
      readSpaceCtx,
      ...supportedSelectors,
      ...comaCTX,
    ];
    const children = [];
    while (!isEOF(exium)) {
      saveStrictContextsTo(exium, allSubContexts, children);
      if (
        [
          "{",
          "}",
        ].includes(getChar(exium)) || isEndOfStylesheet(exium)
      ) {
        break;
      }
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetSelectorList,
      token,
      x,
    );
    context.children.push(...children);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetParentRefCtx(exium, opts1) {
  try {
    const next = getNext(exium);
    const __char = getChar(exium);
    const prev = getPrev(exium);
    const { cursor, source: source2 } = exium;
    const { x } = cursor;
    const isValid = __char === "&" && next !== "&" && prev !== "&";
    if (!isValid) return false;
    if (opts1?.checkOnly) return true;
    shift(exium, 1);
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetParentRef,
      token,
      x,
    );
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetSelectorElementCtx(exium, opts1) {
  try {
    const __char = getChar(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const unsupportedChars = [
      "#",
      ".",
      "[",
      " ",
      "@",
      "{",
      "\n",
      ",",
      "}",
    ];
    const isValid = !unsupportedChars.includes(__char);
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    const result = true;
    const children = [];
    while (!isEOF(exium)) {
      debuggPosition(exium, "\nSELECTOR ELEMENT");
      if (
        [
          "#",
          ".",
          "[",
          ",",
          " ",
          "{",
          ":",
        ].includes(getChar(exium))
      ) {
        break;
      }
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetSelectorHTMLElement,
      token,
      x,
    );
    context.children.push(...children);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetSelectorClassCtx(exium, opts1) {
  debuggPosition(exium, "\nSELECTOR CLASS");
  try {
    const __char = getChar(exium);
    const prev = getPrev(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const previousIsClassStart = prev === "." && __char !== ".";
    const isValid = __char === "." || previousIsClassStart;
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    const result = true;
    const children = [];
    while (!isEOF(exium)) {
      debuggPosition(exium, "\nSELECTOR CLASS");
      if (
        [
          "#",
          "[",
          ",",
          " ",
          "{",
          ":",
        ].includes(getChar(exium))
      ) {
        break;
      }
      shift(exium, 1);
      if (
        [
          ".",
        ].includes(getChar(exium))
      ) {
        break;
      }
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    if (!token.length) return false;
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetSelectorClass,
      token,
      x,
    );
    context.children.push(...children);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetSelectorPseudoClassCtx(exium, opts1) {
  try {
    const __char = getChar(exium);
    const next = getNext(exium);
    const prev = getPrev(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = (__char === ":" || prev === ":") && next !== ":";
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    const result = true;
    const children = [];
    const allSubs = [
      readMultiSpacesCtx,
      readSpaceCtx,
      readLineBreakCtx,
      readParentheseCtx,
    ];
    while (!isEOF(exium)) {
      debuggPosition(exium, "\nSELECTOR PSEUDO CLASS");
      shift(exium, 1);
      if (
        [
          ".",
          "[",
          ",",
          " ",
          "\n",
          "#",
          ":",
          "(",
        ].includes(getChar(exium))
      ) {
        break;
      }
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetSelectorPseudoClass,
      token,
      x,
    );
    saveContextsTo(exium, allSubs, children);
    context.children.push(...children);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetSelectorPseudoElementCtx(exium, opts1) {
  try {
    const __char = getChar(exium);
    const next = getNext(exium);
    const prev = getPrev(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = __char === ":" && next === ":" ||
      prev === ":" && __char === ":";
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    shiftUntilEndOf(exium, "::");
    const result = true;
    const children = [];
    const allSubs = [
      readMultiSpacesCtx,
      readSpaceCtx,
      readLineBreakCtx,
      readParentheseCtx,
    ];
    while (!isEOF(exium)) {
      debuggPosition(exium, "\nSELECTOR PSEUDO ELEMENT");
      shift(exium, 1);
      if (
        [
          ".",
          "[",
          ",",
          " ",
          "\n",
          "#",
          ":",
          "(",
        ].includes(getChar(exium))
      ) {
        break;
      }
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetSelectorPseudoElement,
      token,
      x,
    );
    saveContextsTo(exium, allSubs, children);
    context.children.push(...children);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetSelectorIdCtx(exium, opts1) {
  try {
    const __char = getChar(exium);
    const prev = getPrev(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = __char === "#" || prev === "#";
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    const result = true;
    const children = [];
    while (!isEOF(exium)) {
      debuggPosition(exium, "\nSELECTOR ID");
      shift(exium, 1);
      if (
        [
          ".",
          "[",
          ",",
          " ",
          "\n",
          "#",
          ":",
        ].includes(getChar(exium))
      ) {
        break;
      }
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetSelectorId,
      token,
      x,
    );
    context.children.push(...children);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetSelectorAttributeCtx(exium, opts1) {
  debuggPosition(exium, "\nSELECTOR ATTRIBUTE");
  try {
    const __char = getChar(exium);
    const prev = getPrev(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = __char === "[" || prev === "[" && __char !== "]";
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    let isNamed = false;
    const children = [];
    const related = [];
    const allSubContexts = opts1?.contexts || [
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
    ];
    const propertyOpts = {
      data: {
        allowedIdentifierChars: [
          "-",
          "_",
        ],
      },
    };
    const describers = [
      readIdentifierCtx,
      readStyleSheetSelectorAttributeEqualCtx,
      readStyleSheetSelectorAttributeValueCtx,
    ];
    while (!isEOF(exium)) {
      debuggPosition(exium, "\nSELECTOR ATTRIBUTE");
      if (!isNamed) {
        saveContextsTo(exium, describers, related, propertyOpts);
        isNamed = !!related.find((context) =>
          context.type === ContextTypes1.Identifier
        );
      }
      saveContextsTo(exium, allSubContexts, children);
      shift(exium, 1);
      if (
        [
          "]",
        ].includes(getPrev(exium))
      ) {
        isClosed = true;
        break;
      }
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetSelectorAttribute,
      token,
      x,
    );
    context.children.push(...children);
    context.related.push(...related);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(
        Reason1.StyleSheetAttributeNotClosed,
        exium.cursor,
        context,
      );
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetSelectorAttributeEqualCtx(exium, opts1) {
  debuggPosition(exium, "\nSELECTOR ATTRIBUTE EQUAL START");
  try {
    const __char = getChar(exium);
    const next = getNext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const supported = [
      "^",
      "$",
      "|",
      "*",
      "~",
    ];
    const isValid = supported.includes(__char) && next === "=" ||
      __char === "=";
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    const result = true;
    while (!isEOF(exium)) {
      debuggPosition(exium, "\nSELECTOR ATTRIBUTE EQUAL");
      if (getChar(exium) === "=") {
        shift(exium, 1);
        break;
      }
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetSelectorAttributeEqual,
      token,
      x,
    );
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readSelectorCombinatorCtx(exium, opts1) {
  debuggPosition(exium, "\nSELECTOR COMBINATOR START");
  try {
    const __char = getChar(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const supported = [
      "+",
      ">",
      "~",
      "*",
    ];
    const isValid = supported.includes(__char);
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    const result = true;
    shift(exium, 1);
    const contexts = {
      "~": ContextTypes1.StyleSheetSelectorCombinatorGeneralSibling,
      "*": ContextTypes1.StyleSheetSelectorCombinatorAll,
      "+": ContextTypes1.StyleSheetSelectorCombinatorAdjacentSibling,
      ">": ContextTypes1.StyleSheetSelectorCombinatorChildSelector,
    };
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(contexts[token], token, x);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetSelectorAttributeValueCtx(exium, opts1) {
  debuggPosition(exium, "\nSELECTOR ATTRIBUTE EQUAL START");
  try {
    const lastContext = getLastContext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid =
      lastContext.type === ContextTypes1.StyleSheetSelectorAttributeEqual;
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    const result = true;
    while (!isEOF(exium)) {
      debuggPosition(exium, "\nSELECTOR ATTRIBUTE EQUAL");
      if (getChar(exium) === "]") {
        break;
      }
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetSelectorAttributeValue,
      token,
      x,
    );
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetPropertyListCtx(exium, opts1) {
  debuggPosition(exium, "\nSTYLESHEET PROPERTY LIST START");
  try {
    const __char = getChar(exium);
    const lastContext = getLastContext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const forced = !!opts1?.data?.force_property_list_context;
    const isValid = lastContext.type === ContextTypes1.StyleSheetSelectorList ||
      lastContext.type === ContextTypes1.StyleSheetAtRule ||
      forced && __char === "{";
    if (
      __char !== "{" || !isValid || [
        "}",
      ].includes(__char)
    ) {
      return false;
    }
    if (opts1?.checkOnly) return true;
    shiftUntilEndOf(exium, "{");
    const result = true;
    let isClosed = false;
    const allSubContexts = opts1?.contexts || [
      readMultiSpacesCtx,
      readSpaceCtx,
      readLineBreakCtx,
      readStylesheetEndCtx,
      readStyleSheetSpreadCtx,
      readStyleSheetDefaultAtRuleCtx,
      readStyleSheetSelectorListCtx,
      readStyleSheetPropertyListCtx,
      readStylesheetPropertyCtx,
    ];
    const children = [];
    while (!isEOF(exium)) {
      debuggPosition(exium, "\nSTYLESHEET PROPERTY LIST");
      if (getChar(exium) === "}") {
        shift(exium, 1);
        isClosed = true;
        break;
      }
      saveStrictContextsTo(exium, allSubContexts, children);
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetPropertyList,
      token,
      x,
    );
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(Reason1.StyleSheetPropertyListOpen, exium.cursor, context);
    }
    if (!forced) lastContext.related.push(context);
    debuggPosition(exium, "\nSTYLESHEET PROPERTY END");
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetSpreadCtx(exium, opts1) {
  debuggPosition(exium, "\nSTYLESHEET RULE SPREAD START");
  try {
    const __char = getChar(exium);
    const next = getNext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = [
      __char,
      next,
      source2[x + 2],
    ].join("") === "...";
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    shiftUntilEndOf(exium, "...");
    const result = true;
    const related = [];
    const subs = [
      readIdentifierCtx,
      readSemiColonCtx,
    ];
    const unexpected = opts1?.unexpected || [
      readMultiSpacesCtx,
      readSpaceCtx,
      readLineBreakCtx,
    ];
    let isNamed = false;
    while (!isEOF(exium)) {
      debuggPosition(exium, "\nSTYLESHEET RULE SPREAD");
      saveStrictContextsTo(exium, subs, related);
      isNamed = !!related.find((context) =>
        context.type === ContextTypes1.Identifier
      );
      if (related.find((context) => context.type === ContextTypes1.SemiColon)) {
        if (!isNamed) {
          exium.onError(
            Reason1.StyleSheetRuleSpreadNameMissing,
            exium.cursor,
            getUnexpected(exium),
          );
        }
        break;
      }
      isValidChar(exium, unexpected);
      shift(exium, 1);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetRuleSpread,
      token,
      x,
    );
    context.related.push(...related);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStylesheetPropertyCtx(exium, opts1) {
  debuggPosition(exium, "\nSELECTOR PROPERTY START");
  try {
    const __char = getChar(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const unsupported = [
      ":",
      "@",
      " ",
      ";",
      "}",
      "\n",
      ".",
      "(",
      ")",
    ];
    const isValid = !unsupported.includes(__char);
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    const result = true;
    const related = [];
    const children = [];
    const describers = [
      readIdentifierCtx,
      readDoublePointCtx,
      readStyleSheetPseudoPropertyCtx,
      readStylesheetPropertyValueCtx,
    ];
    const propertyOpts = {
      data: {
        allowedIdentifierChars: [
          "-",
          "_",
          "%",
        ],
        allowDigit: true,
      },
    };
    const subs = [
      readSemiColonCtx,
    ];
    let isNamed = false;
    while (!isEOF(exium)) {
      debuggPosition(exium, "\nSELECTOR PROPERTY");
      if (!isNamed) {
        saveStrictContextsTo(exium, describers, related, propertyOpts);
        isNamed = Boolean(
          related.find((context) =>
            context.type === ContextTypes1.Identifier
          ) && related.find((context) =>
            context.type === ContextTypes1.DoublePoint
          ) && related.find((context) =>
            context.type === ContextTypes1.StyleSheetPropertyValue
          ),
        );
      }
      saveContextsTo(exium, subs, children);
      if (
        children.find((context) => context.type === ContextTypes1.SemiColon) ||
        [
          "}",
        ].includes(getChar(exium)) || isEndOfStylesheetProperty(exium)
      ) {
        break;
      }
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetProperty,
      token,
      x,
    );
    context.related.push(...related);
    context.children.push(...children);
    exium.currentContexts.push(context);
    return true;
  } catch (err) {
    throw err;
  }
}
function readStyleSheetPseudoPropertyCtx(exium, opts1) {
  debuggPosition(exium, "\nSELECTOR PSEUDO PROPERTY START");
  try {
    const __char = getChar(exium);
    const lastContext = getLastContext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = !exium.isInPseudoProperty && __char === ":" &&
      lastContext.type === ContextTypes1.DoublePoint;
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    exium.isInPseudoProperty = true;
    const result = true;
    let isClosed = false;
    const children = [];
    const related = [];
    const exitChars = [
      ";",
      "\n",
      "}",
      ")",
    ];
    const subs = [
      readBracesCtx,
    ];
    const describers = [
      readIdentifierCtx,
    ];
    const unexpected = opts1?.unexpected || [
      readMultiSpacesCtx,
      readSpaceCtx,
      readLineBreakCtx,
    ];
    shiftUntilEndOf(exium, ":");
    saveStrictContextsTo(exium, describers, related, {
      data: {
        allowedIdentifierChars: [
          "-",
        ],
      },
    });
    while (!isEOF(exium)) {
      isValidChar(exium, unexpected);
      debuggPosition(exium, "\nSELECTOR PSEUDO PROPERTY");
      saveStrictContextsTo(exium, subs, children, {
        data: {
          braces_contexts: [
            readStylesheetPropertyCtx,
          ],
        },
      });
      if (exitChars.includes(getChar(exium))) {
        isClosed = true;
        break;
      }
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetPseudoProperty,
      token,
      x,
    );
    context.children.push(...children);
    context.related.push(...related);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(
        Reason1.StyleSheetRulePropertyValueNotClosed,
        exium.cursor,
        context,
      );
    }
    exium.isInPseudoProperty = false;
    return true;
  } catch (err) {
    throw err;
  }
}
function readStylesheetPropertyValueCtx(exium, opts1) {
  debuggPosition(exium, "\nSELECTOR PROPERTY VALUE START");
  try {
    const __char = getChar(exium);
    const lastContext = getLastContext(exium);
    const { x } = exium.cursor;
    const { source: source2 } = exium;
    const isValid = lastContext.type === ContextTypes1.DoublePoint &&
      __char !== ":";
    if (!isValid) return isValid;
    if (opts1?.checkOnly) return true;
    const result = true;
    let isClosed = false;
    const exitChars = [
      ";",
      "\n",
      "}",
    ];
    const children = [];
    const subs = [
      readLineBreakCtx,
      readMultiSpacesCtx,
      readSpaceCtx,
      readStringDoubleQuoteCtx,
      readStringSingleQuoteCtx,
      readBracesCtx,
    ];
    while (!isEOF(exium)) {
      debuggPosition(exium, "\nSELECTOR PROPERTY VALUE");
      saveContextsTo(exium, subs, children, {
        data: {
          readArgumentCtx_starts_with: "|",
        },
        contexts: subs,
      });
      if (
        exitChars.includes(getChar(exium)) || isEndOfStylesheetProperty(exium)
      ) {
        isClosed = true;
        break;
      }
      shift(exium, 1);
      isValidChar(exium, opts1?.unexpected);
    }
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(
      ContextTypes1.StyleSheetPropertyValue,
      token,
      x,
    );
    context.children.push(...children);
    exium.currentContexts.push(context);
    if (!isClosed) {
      exium.onError(
        Reason1.StyleSheetRulePropertyValueNotClosed,
        exium.cursor,
        context,
      );
    }
    return true;
  } catch (err) {
    throw err;
  }
}
function readStylesheetEndCtx(exium) {
  const nextPart = getNextPart(exium);
  const { source: source2 } = exium;
  const { x } = exium.cursor;
  const reg = /^([\s\n]*?)(\<\/style)/i;
  const isValid = reg.test(nextPart);
  if (!isValid) return isValid;
  debuggPosition(exium, "\nSTYLESHEET END <==================");
  const match = nextPart.match(reg);
  if (match) {
    const token = source2.slice(x, exium.cursor.x);
    const context = new ExiumContext1(ContextTypes1.StyleSheetEnd, token, x);
    exium.currentContexts.push(context);
    return null;
  }
  return false;
}
